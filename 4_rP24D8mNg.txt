1
00:00:00,000 --> 00:00:01,599
so hello there and welcome to another

2
00:00:01,599 --> 00:00:03,360
tutorial my name is tammy bakshi and

3
00:00:03,360 --> 00:00:04,640
today we're going to be going over how

4
00:00:04,640 --> 00:00:06,640
you can build your own llvm function

5
00:00:06,640 --> 00:00:09,360
passes to modify your code at compile

6
00:00:09,360 --> 00:00:11,840
time using the llvm compiler

7
00:00:11,840 --> 00:00:14,000
infrastructure tooling uh now this is a

8
00:00:14,000 --> 00:00:16,160
follow up video to my existing video on

9
00:00:16,160 --> 00:00:18,720
the llvm compiler infrastructure once

10
00:00:18,720 --> 00:00:20,800
again if you'd like to learn more about

11
00:00:20,800 --> 00:00:23,680
what llvm is why it exists what it

12
00:00:23,680 --> 00:00:25,199
enables you to do please do check out

13
00:00:25,199 --> 00:00:26,960
that first video but if you're already

14
00:00:26,960 --> 00:00:28,960
familiar with what llvm is and you want

15
00:00:28,960 --> 00:00:30,320
to get started actually building your

16
00:00:30,320 --> 00:00:31,679
own function passes and your own

17
00:00:31,679 --> 00:00:33,600
extensions to the compiler then this

18
00:00:33,600 --> 00:00:36,239
video is for you now before i do get

19
00:00:36,239 --> 00:00:37,360
into this i do want to start off by

20
00:00:37,360 --> 00:00:38,399
saying that if you enjoy this kind of

21
00:00:38,399 --> 00:00:39,600
content you want to see more of it

22
00:00:39,600 --> 00:00:40,879
please do make sure to subscribe to the

23
00:00:40,879 --> 00:00:42,399
channel as it really does help out a lot

24
00:00:42,399 --> 00:00:43,760
and turn on notifications you're

25
00:00:43,760 --> 00:00:45,200
notified whenever i release videos like

26
00:00:45,200 --> 00:00:46,960
this one today apart from that like the

27
00:00:46,960 --> 00:00:48,239
video if you enjoyed it and if you have

28
00:00:48,239 --> 00:00:50,000
any questions suggestions for feedback

29
00:00:50,000 --> 00:00:51,360
leave it down in the comment section

30
00:00:51,360 --> 00:00:54,640
below and i'd love uh to get in touch

31
00:00:54,640 --> 00:00:57,360
now diving right into what we have to

32
00:00:57,360 --> 00:00:59,920
show today once again llvm just as a

33
00:00:59,920 --> 00:01:03,120
quick recap is as i've said before

34
00:01:03,120 --> 00:01:05,840
compiler infrastructure so say for

35
00:01:05,840 --> 00:01:07,200
example you're developing a swift

36
00:01:07,200 --> 00:01:09,439
compiler or a rust compiler a c compiler

37
00:01:09,439 --> 00:01:11,840
pretty much any language instead of

38
00:01:11,840 --> 00:01:14,000
building the entire compiler yourself

39
00:01:14,000 --> 00:01:16,000
taking all the way from your high level

40
00:01:16,000 --> 00:01:19,119
code creating an abstract syntax tree

41
00:01:19,119 --> 00:01:20,640
creating an intermediate representation

42
00:01:20,640 --> 00:01:22,799
then finally exporting machine code

43
00:01:22,799 --> 00:01:24,000
instead of having to go through that

44
00:01:24,000 --> 00:01:26,560
entire pipeline you can actually skip

45
00:01:26,560 --> 00:01:30,000
the entire backend portion by using llvm

46
00:01:30,000 --> 00:01:32,000
what it enables you to do is take your

47
00:01:32,000 --> 00:01:34,240
language effectively translate it into

48
00:01:34,240 --> 00:01:36,640
one sort of universal yet very low level

49
00:01:36,640 --> 00:01:39,759
representation which they call llvmir

50
00:01:39,759 --> 00:01:41,680
intermediate representation and then

51
00:01:41,680 --> 00:01:44,479
pass that over to the llvm compiler the

52
00:01:44,479 --> 00:01:46,399
llvm compiler

53
00:01:46,399 --> 00:01:48,479
will then go ahead and take your

54
00:01:48,479 --> 00:01:50,640
intermediate representation run a bunch

55
00:01:50,640 --> 00:01:54,159
of industry standard optimizations on it

56
00:01:54,159 --> 00:01:56,079
and then go ahead and export for you

57
00:01:56,079 --> 00:01:58,000
machine code to a variety of different

58
00:01:58,000 --> 00:02:00,479
architectures all the way from x86 and

59
00:02:00,479 --> 00:02:05,040
arm to power and ibm z and so much more

60
00:02:05,040 --> 00:02:07,040
now llvm is super useful because it

61
00:02:07,040 --> 00:02:08,800
enables things like for example code

62
00:02:08,800 --> 00:02:11,360
reuse right so one language like swift

63
00:02:11,360 --> 00:02:12,800
for example thinks of an incredible

64
00:02:12,800 --> 00:02:15,120
optimization for code well them

65
00:02:15,120 --> 00:02:17,120
implementing that optimization into the

66
00:02:17,120 --> 00:02:20,319
llvmir stack suddenly benefits a lot of

67
00:02:20,319 --> 00:02:22,640
other languages as well and because of

68
00:02:22,640 --> 00:02:24,879
this code is a lot more portable too

69
00:02:24,879 --> 00:02:27,760
like for example rust right rust has two

70
00:02:27,760 --> 00:02:29,440
other intermediate representations

71
00:02:29,440 --> 00:02:31,760
before it goes to llvm that are rust

72
00:02:31,760 --> 00:02:33,680
specific enabling it to do rough

73
00:02:33,680 --> 00:02:35,760
specific optimizations but it still

74
00:02:35,760 --> 00:02:37,920
lowers down to an llvm layer where it

75
00:02:37,920 --> 00:02:39,680
can then be compiled to any of the

76
00:02:39,680 --> 00:02:42,480
target architectures that llvm already

77
00:02:42,480 --> 00:02:44,800
supports this makes it so it's a lot

78
00:02:44,800 --> 00:02:47,200
easier for developers on the compiler

79
00:02:47,200 --> 00:02:49,360
team to support tons of architectures

80
00:02:49,360 --> 00:02:52,000
without a ton more work

81
00:02:52,000 --> 00:02:54,800
now what's uh the way that llvm works

82
00:02:54,800 --> 00:02:56,879
right the way this sort of architecture

83
00:02:56,879 --> 00:02:58,000
is

84
00:02:58,000 --> 00:03:00,239
is there are individual what they call

85
00:03:00,239 --> 00:03:03,680
passes that llvm will run on your ir

86
00:03:03,680 --> 00:03:06,080
during the compilation phase so for

87
00:03:06,080 --> 00:03:07,519
example if you wrote c code you're

88
00:03:07,519 --> 00:03:09,760
compiling with clang and you use dash o

89
00:03:09,760 --> 00:03:11,519
fast it'll use pretty much every

90
00:03:11,519 --> 00:03:13,280
optimization it can right so you're

91
00:03:13,280 --> 00:03:14,800
telling clang hey use the highest

92
00:03:14,800 --> 00:03:16,959
optimization level possible what that's

93
00:03:16,959 --> 00:03:19,599
doing is it's telling llvm hey of all

94
00:03:19,599 --> 00:03:21,840
the different function passes and module

95
00:03:21,840 --> 00:03:24,000
passes that you have there's even more

96
00:03:24,000 --> 00:03:26,640
like loop passes run them all on this

97
00:03:26,640 --> 00:03:28,480
code not necessarily all of them but a

98
00:03:28,480 --> 00:03:30,720
lot of them on this code

99
00:03:30,720 --> 00:03:32,720
to modify it in such a way that we

100
00:03:32,720 --> 00:03:34,480
believe would make it faster right so

101
00:03:34,480 --> 00:03:36,319
for example some passes could be

102
00:03:36,319 --> 00:03:38,879
responsible for uh taking a function

103
00:03:38,879 --> 00:03:40,799
call to a very small function and

104
00:03:40,799 --> 00:03:42,560
inlining the function content right that

105
00:03:42,560 --> 00:03:44,159
would be a function pass you're looking

106
00:03:44,159 --> 00:03:45,280
at functions that are being called

107
00:03:45,280 --> 00:03:47,120
seeing if you have the available code

108
00:03:47,120 --> 00:03:49,680
for it and if you do in lining that call

109
00:03:49,680 --> 00:03:51,200
another thing might be for example a

110
00:03:51,200 --> 00:03:53,120
loop pass to be able to fuse together

111
00:03:53,120 --> 00:03:54,879
multiple different loops in order to

112
00:03:54,879 --> 00:03:56,959
avoid extra branching and instructions

113
00:03:56,959 --> 00:03:58,799
right so these passes are responsible

114
00:03:58,799 --> 00:04:01,360
for taking your ir analyzing them trying

115
00:04:01,360 --> 00:04:03,040
to find patterns that they believe would

116
00:04:03,040 --> 00:04:05,760
be slow and optimizing them by

117
00:04:05,760 --> 00:04:07,760
introducing different sets of code that

118
00:04:07,760 --> 00:04:10,000
should have the exact same behavior and

119
00:04:10,000 --> 00:04:11,120
result

120
00:04:11,120 --> 00:04:12,799
but should be able to do it in a more

121
00:04:12,799 --> 00:04:14,799
efficient manner that's the point of

122
00:04:14,799 --> 00:04:16,160
these passes

123
00:04:16,160 --> 00:04:18,400
now not all passes have to be

124
00:04:18,400 --> 00:04:20,479
optimization passes some passes for

125
00:04:20,479 --> 00:04:23,199
example can be for analytics or for you

126
00:04:23,199 --> 00:04:25,680
to insert instrumentation into your code

127
00:04:25,680 --> 00:04:28,320
and as an example today i want to show

128
00:04:28,320 --> 00:04:30,320
you how you can build a function pass

129
00:04:30,320 --> 00:04:32,080
that will enable you to insert

130
00:04:32,080 --> 00:04:34,080
effectively arbitrary code into any

131
00:04:34,080 --> 00:04:36,240
function except this specific function

132
00:04:36,240 --> 00:04:38,479
pass will take every function and every

133
00:04:38,479 --> 00:04:40,400
single time a function enters it'll

134
00:04:40,400 --> 00:04:42,000
insert a print statement printing out

135
00:04:42,000 --> 00:04:43,280
the name of the function that just

136
00:04:43,280 --> 00:04:46,560
entered and it'll also print a number of

137
00:04:46,560 --> 00:04:49,040
how many times that function has been

138
00:04:49,040 --> 00:04:51,440
called in this specific invocation of

139
00:04:51,440 --> 00:04:53,759
the program so let's go ahead and take a

140
00:04:53,759 --> 00:04:56,400
look at how you would do that um as you

141
00:04:56,400 --> 00:04:58,000
can see over here

142
00:04:58,000 --> 00:05:00,960
i've got my terminal window open um and

143
00:05:00,960 --> 00:05:02,400
we we i've just opened up a simple

144
00:05:02,400 --> 00:05:04,479
docker container i've already installed

145
00:05:04,479 --> 00:05:06,960
llvm it's a reasonably straightforward

146
00:05:06,960 --> 00:05:09,120
procedure to do so especially on linux

147
00:05:09,120 --> 00:05:10,160
so there will be a link to the

148
00:05:10,160 --> 00:05:12,000
description link in the description down

149
00:05:12,000 --> 00:05:14,720
below um to the llvm compiler tooling

150
00:05:14,720 --> 00:05:16,240
and how you can get started

151
00:05:16,240 --> 00:05:18,000
by installing it

152
00:05:18,000 --> 00:05:19,600
and sort of getting a development

153
00:05:19,600 --> 00:05:21,440
environment ready and set up

154
00:05:21,440 --> 00:05:23,440
i built it from source personally since

155
00:05:23,440 --> 00:05:25,120
i found it easier to install that way

156
00:05:25,120 --> 00:05:26,720
but there are other ways to install

157
00:05:26,720 --> 00:05:29,120
pre-built versions as well

158
00:05:29,120 --> 00:05:32,000
now in this directory i've got a pretty

159
00:05:32,000 --> 00:05:34,560
simple c plus plus file open up here

160
00:05:34,560 --> 00:05:36,720
and the c plus file is what's going to

161
00:05:36,720 --> 00:05:39,520
enable us um to run our function pass

162
00:05:39,520 --> 00:05:41,600
this is the source code for the llvm

163
00:05:41,600 --> 00:05:43,440
function pass that i was talking about

164
00:05:43,440 --> 00:05:46,560
um it's actually not too bad um and it

165
00:05:46,560 --> 00:05:48,560
sort of split up into a couple of main

166
00:05:48,560 --> 00:05:49,919
sections the first one is our

167
00:05:49,919 --> 00:05:51,360
initialization so literally just you

168
00:05:51,360 --> 00:05:52,800
know simple includes and using

169
00:05:52,800 --> 00:05:55,199
namespaces um then of course is the

170
00:05:55,199 --> 00:05:57,520
actual function pass sort of you know

171
00:05:57,520 --> 00:05:59,039
what you really need to worry about is

172
00:05:59,039 --> 00:06:01,759
lines 20 through 45

173
00:06:01,759 --> 00:06:03,520
and then after those lines

174
00:06:03,520 --> 00:06:05,840
are the lines that we use to register

175
00:06:05,840 --> 00:06:08,240
the function pass with llvm to tell it

176
00:06:08,240 --> 00:06:10,560
how to invoke this function pass

177
00:06:10,560 --> 00:06:12,400
i'll get into sort of the structure of

178
00:06:12,400 --> 00:06:14,240
this code in just a moment

179
00:06:14,240 --> 00:06:16,880
really quickly though to begin i do want

180
00:06:16,880 --> 00:06:19,120
to sort of prime you to what you're

181
00:06:19,120 --> 00:06:21,759
about to read before we actually dig

182
00:06:21,759 --> 00:06:23,199
into it

183
00:06:23,199 --> 00:06:25,600
now as i've taught uh different people

184
00:06:25,600 --> 00:06:28,240
how to work with llvm and honestly even

185
00:06:28,240 --> 00:06:29,840
other compilers or even interpreters

186
00:06:29,840 --> 00:06:31,759
like the python interpreters python

187
00:06:31,759 --> 00:06:33,840
interpreter i've noticed that one sort

188
00:06:33,840 --> 00:06:35,520
of common thread that is kind of

189
00:06:35,520 --> 00:06:37,199
confusing when you're starting to work

190
00:06:37,199 --> 00:06:38,639
with this technology

191
00:06:38,639 --> 00:06:40,960
is that you have to really keep in mind

192
00:06:40,960 --> 00:06:43,520
that you are not necessarily just

193
00:06:43,520 --> 00:06:46,240
writing code here you are writing code

194
00:06:46,240 --> 00:06:49,280
that is responsible for writing code

195
00:06:49,280 --> 00:06:51,199
that's a very important distinction to

196
00:06:51,199 --> 00:06:53,759
keep in mind right like for example as i

197
00:06:53,759 --> 00:06:55,120
was explaining the global interpreter

198
00:06:55,120 --> 00:06:57,440
lock to um to to someone who had a

199
00:06:57,440 --> 00:07:00,240
question uh in in in python which by the

200
00:07:00,240 --> 00:07:02,000
way is effectively a mutex that makes it

201
00:07:02,000 --> 00:07:04,080
so the python interpreter can only ever

202
00:07:04,080 --> 00:07:06,560
run one thread at a time so in python

203
00:07:06,560 --> 00:07:08,479
multi-threading is technically i mean

204
00:07:08,479 --> 00:07:09,840
multi-threading but you're only ever

205
00:07:09,840 --> 00:07:11,039
running a single thread at once anyway

206
00:07:11,039 --> 00:07:12,319
that's a different discussion you know

207
00:07:12,319 --> 00:07:15,599
it's sort of hard to understand um from

208
00:07:15,599 --> 00:07:17,759
a high level at least why these things

209
00:07:17,759 --> 00:07:19,840
are necessary before you really think

210
00:07:19,840 --> 00:07:21,680
about the fact that you're talking about

211
00:07:21,680 --> 00:07:23,440
programs that are responsible for

212
00:07:23,440 --> 00:07:26,160
executing or writing other programs

213
00:07:26,160 --> 00:07:27,360
right so

214
00:07:27,360 --> 00:07:29,199
as you're looking at this llvm function

215
00:07:29,199 --> 00:07:31,520
pass here really keep in mind that what

216
00:07:31,520 --> 00:07:35,440
we're doing here is we are writing code

217
00:07:35,440 --> 00:07:38,319
to write code right so for example if i

218
00:07:38,319 --> 00:07:40,479
say we are inserting a function call i

219
00:07:40,479 --> 00:07:42,080
don't mean we're actually calling a

220
00:07:42,080 --> 00:07:44,960
function we are writing instructions we

221
00:07:44,960 --> 00:07:48,000
are calling llvm api functions that are

222
00:07:48,000 --> 00:07:50,720
responsible for inserting an actual

223
00:07:50,720 --> 00:07:52,879
function called instruction into code

224
00:07:52,879 --> 00:07:55,039
that we'll be compiling later on that

225
00:07:55,039 --> 00:07:57,440
uses this plugin right

226
00:07:57,440 --> 00:07:59,199
that's really important to keep in mind

227
00:07:59,199 --> 00:08:01,599
now heading back over to the actual uh

228
00:08:01,599 --> 00:08:02,960
function pass here

229
00:08:02,960 --> 00:08:04,240
as i mentioned we start off with some

230
00:08:04,240 --> 00:08:05,919
simple initializations so we have some

231
00:08:05,919 --> 00:08:08,960
simple includes um and also by the way

232
00:08:08,960 --> 00:08:11,360
this is c plus code but you can write

233
00:08:11,360 --> 00:08:13,520
llvm code in other languages as well

234
00:08:13,520 --> 00:08:15,039
there are bindings for languages like

235
00:08:15,039 --> 00:08:17,039
swift and i believe also safe bindings

236
00:08:17,039 --> 00:08:19,120
for languages like rust in case you're

237
00:08:19,120 --> 00:08:21,440
into that um if you'd like

238
00:08:21,440 --> 00:08:23,280
i can also work on a youtube sort of

239
00:08:23,280 --> 00:08:25,280
video series on building some more of

240
00:08:25,280 --> 00:08:26,479
these uh

241
00:08:26,479 --> 00:08:28,319
more of these like llvm passes in

242
00:08:28,319 --> 00:08:30,080
languages like rust that i think would

243
00:08:30,080 --> 00:08:32,320
be a lot more fun so let me know if

244
00:08:32,320 --> 00:08:34,399
you'd like to see those tutorials

245
00:08:34,399 --> 00:08:36,240
now moving a forward from here again

246
00:08:36,240 --> 00:08:37,760
simple c plus plus stuff using the two

247
00:08:37,760 --> 00:08:39,760
namespaces lvm and std that we're going

248
00:08:39,760 --> 00:08:40,800
to need

249
00:08:40,800 --> 00:08:43,039
and this is where the fun part starts

250
00:08:43,039 --> 00:08:44,959
now we get to actually create the

251
00:08:44,959 --> 00:08:46,640
function pass

252
00:08:46,640 --> 00:08:48,000
now what we're doing here is creating a

253
00:08:48,000 --> 00:08:50,240
simple structure called runtime print

254
00:08:50,240 --> 00:08:52,320
function call count pass

255
00:08:52,320 --> 00:08:55,920
rules right at the tongue um and it's it

256
00:08:55,920 --> 00:08:58,320
it's it's right it's derived from uh the

257
00:08:58,320 --> 00:09:01,200
function pass uh that comes from the

258
00:09:01,200 --> 00:09:03,519
llvm api so function pass comes from

259
00:09:03,519 --> 00:09:06,000
llvm we're saying that this uh structure

260
00:09:06,000 --> 00:09:08,959
sort of inherits from function pass

261
00:09:08,959 --> 00:09:11,279
we create a super simple initializer

262
00:09:11,279 --> 00:09:13,440
that literally just takes an id

263
00:09:13,440 --> 00:09:15,279
this initializer is never called by you

264
00:09:15,279 --> 00:09:17,279
right you never initialize this

265
00:09:17,279 --> 00:09:18,959
structure yourself

266
00:09:18,959 --> 00:09:21,519
that's done by llvm when it's invoking

267
00:09:21,519 --> 00:09:23,600
your function pass which is why we're

268
00:09:23,600 --> 00:09:25,360
just sort of following boilerplate here

269
00:09:25,360 --> 00:09:27,120
effectively

270
00:09:27,120 --> 00:09:28,959
next is a function that you're supposed

271
00:09:28,959 --> 00:09:30,959
to sort of like overload here it's

272
00:09:30,959 --> 00:09:33,920
called a run on function now the run on

273
00:09:33,920 --> 00:09:35,600
function function

274
00:09:35,600 --> 00:09:38,160
again kind of difficult to keep track of

275
00:09:38,160 --> 00:09:39,279
uh you know

276
00:09:39,279 --> 00:09:41,040
what exactly here is code that we're

277
00:09:41,040 --> 00:09:42,880
writing versus code that's being invoked

278
00:09:42,880 --> 00:09:46,080
but the run on function function is a

279
00:09:46,080 --> 00:09:48,640
function that will be run on every

280
00:09:48,640 --> 00:09:51,839
function in your llvm module

281
00:09:51,839 --> 00:09:52,720
so

282
00:09:52,720 --> 00:09:54,800
what this means is when you're compiling

283
00:09:54,800 --> 00:09:57,120
for example a c file with clang

284
00:09:57,120 --> 00:09:59,839
and you tell clang to use your function

285
00:09:59,839 --> 00:10:00,800
pass

286
00:10:00,800 --> 00:10:03,480
it will internally take every

287
00:10:03,480 --> 00:10:06,880
llvmir function

288
00:10:06,880 --> 00:10:09,680
pass that as an object to

289
00:10:09,680 --> 00:10:12,160
run on function within your pass right

290
00:10:12,160 --> 00:10:14,560
so this takes a function this is not

291
00:10:14,560 --> 00:10:16,320
like an actual function pointer you

292
00:10:16,320 --> 00:10:18,160
can't actually call this this is not

293
00:10:18,160 --> 00:10:20,480
fully compiled it is

294
00:10:20,480 --> 00:10:24,399
an object that contains the llvmir for

295
00:10:24,399 --> 00:10:26,000
what you are currently compiling right

296
00:10:26,000 --> 00:10:28,240
this is not an actual function loaded

297
00:10:28,240 --> 00:10:30,399
into executable memory this is a

298
00:10:30,399 --> 00:10:32,959
sequence of llvmir instructions in an

299
00:10:32,959 --> 00:10:35,360
object that you can now mutate or

300
00:10:35,360 --> 00:10:38,240
analyze however you wish

301
00:10:38,240 --> 00:10:41,040
um now what this function does to start

302
00:10:41,040 --> 00:10:43,519
off with is we simply get the llvm

303
00:10:43,519 --> 00:10:44,720
context that we're dealing with and this

304
00:10:44,720 --> 00:10:46,880
gives us like compile information and

305
00:10:46,880 --> 00:10:49,440
then we go ahead and um take a look at

306
00:10:49,440 --> 00:10:51,519
what module we're in right so we want to

307
00:10:51,519 --> 00:10:54,240
figure out you know this llvm function

308
00:10:54,240 --> 00:10:55,920
that would that we've been passed what

309
00:10:55,920 --> 00:10:58,320
is the larger module that it's a part of

310
00:10:58,320 --> 00:11:00,000
which effectively you could think of as

311
00:11:00,000 --> 00:11:02,720
the file of code that you're compiling

312
00:11:02,720 --> 00:11:04,959
um using llvm

313
00:11:04,959 --> 00:11:06,880
the next thing that we do is we start

314
00:11:06,880 --> 00:11:08,399
initializing a couple of variables that

315
00:11:08,399 --> 00:11:10,079
are necessary for what we actually want

316
00:11:10,079 --> 00:11:12,320
to insert remember we want to insert

317
00:11:12,320 --> 00:11:14,399
into the beginning of every function a

318
00:11:14,399 --> 00:11:17,040
call to printf to make it print what

319
00:11:17,040 --> 00:11:19,519
function has just been called and also

320
00:11:19,519 --> 00:11:21,680
how many times it's been called in order

321
00:11:21,680 --> 00:11:24,480
to do so we need to know the signature

322
00:11:24,480 --> 00:11:27,360
of the printf function

323
00:11:27,360 --> 00:11:28,640
to get that signature is kind of

324
00:11:28,640 --> 00:11:31,360
complicated so like in an actual c file

325
00:11:31,360 --> 00:11:33,120
what you would do is you would

326
00:11:33,120 --> 00:11:35,760
you would probably just include stdio.h

327
00:11:35,760 --> 00:11:37,760
but if you didn't want to use that

328
00:11:37,760 --> 00:11:40,399
header you would actually write

329
00:11:40,399 --> 00:11:43,519
a function signature uh something like

330
00:11:43,519 --> 00:11:46,399
uh int um printf

331
00:11:46,399 --> 00:11:47,760
const car

332
00:11:47,760 --> 00:11:48,720
um

333
00:11:48,720 --> 00:11:50,800
str like so

334
00:11:50,800 --> 00:11:52,959
um and then it takes like variatic

335
00:11:52,959 --> 00:11:54,720
arguments like so right so you would

336
00:11:54,720 --> 00:11:56,639
write something like this

337
00:11:56,639 --> 00:12:00,160
um in your uh in in like a header file

338
00:12:00,160 --> 00:12:02,560
somewhere in order to tell see that hey

339
00:12:02,560 --> 00:12:05,120
somewhere there's going to be a function

340
00:12:05,120 --> 00:12:06,560
called printf and you know your linker

341
00:12:06,560 --> 00:12:09,120
can deal with it later um but the

342
00:12:09,120 --> 00:12:10,399
problem is that we're not actually

343
00:12:10,399 --> 00:12:12,639
writing that c code right now we are

344
00:12:12,639 --> 00:12:16,240
writing llvm code um that needs to or

345
00:12:16,240 --> 00:12:18,639
rather we are using the llvm api to

346
00:12:18,639 --> 00:12:21,600
write llvm ir code

347
00:12:21,600 --> 00:12:22,880
so what we have to do is we have to

348
00:12:22,880 --> 00:12:26,160
formally create a function type object

349
00:12:26,160 --> 00:12:28,399
from the llvm api tell it that the

350
00:12:28,399 --> 00:12:32,000
return type is an integer 32 type also

351
00:12:32,000 --> 00:12:34,480
coming from the llvm api and the only

352
00:12:34,480 --> 00:12:38,240
argument is an 8 bit integer pointer

353
00:12:38,240 --> 00:12:39,120
type

354
00:12:39,120 --> 00:12:41,360
um this means the character pointer

355
00:12:41,360 --> 00:12:42,639
because characters are eight bit

356
00:12:42,639 --> 00:12:46,160
integers um and of course true here

357
00:12:46,160 --> 00:12:48,560
means that this is a variation function

358
00:12:48,560 --> 00:12:50,240
it takes you know an arbitrary number of

359
00:12:50,240 --> 00:12:51,600
arguments after the ones that have

360
00:12:51,600 --> 00:12:54,160
already been specified in this set

361
00:12:54,160 --> 00:12:56,480
once we've got that function type we

362
00:12:56,480 --> 00:12:58,320
actually go ahead and sort of create

363
00:12:58,320 --> 00:13:01,200
that signature with a name right so this

364
00:13:01,200 --> 00:13:02,480
over here

365
00:13:02,480 --> 00:13:05,600
is telling the module to either get or

366
00:13:05,600 --> 00:13:09,040
insert a function named printf of this

367
00:13:09,040 --> 00:13:11,360
type so what that's going to do is if a

368
00:13:11,360 --> 00:13:13,040
signature for this already exists within

369
00:13:13,040 --> 00:13:15,200
the module you'll be returned this

370
00:13:15,200 --> 00:13:17,440
function kali object that allows you to

371
00:13:17,440 --> 00:13:19,120
insert like for example function calls

372
00:13:19,120 --> 00:13:21,920
to this function callee

373
00:13:21,920 --> 00:13:23,680
or if it doesn't exist it will be

374
00:13:23,680 --> 00:13:25,920
inserted into the module and then passed

375
00:13:25,920 --> 00:13:27,760
back to you

376
00:13:27,760 --> 00:13:29,920
and that is what enables you to figure

377
00:13:29,920 --> 00:13:32,480
out what printf is and how to call it

378
00:13:32,480 --> 00:13:34,560
next thing we got to do is actually

379
00:13:34,560 --> 00:13:35,519
start

380
00:13:35,519 --> 00:13:37,600
inserting code um

381
00:13:37,600 --> 00:13:40,079
now once again the entire point of this

382
00:13:40,079 --> 00:13:42,160
is that we want to print out the name of

383
00:13:42,160 --> 00:13:43,839
the functions

384
00:13:43,839 --> 00:13:45,760
now the way we're going to do this is by

385
00:13:45,760 --> 00:13:47,120
starting out

386
00:13:47,120 --> 00:13:48,320
by actually getting the name of the

387
00:13:48,320 --> 00:13:50,720
function so we get the llvm function's

388
00:13:50,720 --> 00:13:52,560
name using get name this gives us a

389
00:13:52,560 --> 00:13:54,959
special type called called an llvm twine

390
00:13:54,959 --> 00:13:56,880
which we then convert to an actual c

391
00:13:56,880 --> 00:13:58,480
plus plus string just to make it easier

392
00:13:58,480 --> 00:14:00,000
to deal with

393
00:14:00,000 --> 00:14:02,320
and then i also create a new string

394
00:14:02,320 --> 00:14:04,880
which is a function name with underscore

395
00:14:04,880 --> 00:14:07,040
call count appended to it the reason

396
00:14:07,040 --> 00:14:09,279
we're doing this is because another

397
00:14:09,279 --> 00:14:11,120
thing we want this pass to do is keep

398
00:14:11,120 --> 00:14:12,959
track of how many times each function's

399
00:14:12,959 --> 00:14:15,040
been called the way i do this is by

400
00:14:15,040 --> 00:14:17,760
using a global variable called function

401
00:14:17,760 --> 00:14:20,399
name underscore call count by default we

402
00:14:20,399 --> 00:14:22,320
set it to zero and every single time a

403
00:14:22,320 --> 00:14:24,160
function is called it's incremented

404
00:14:24,160 --> 00:14:26,720
before being printed

405
00:14:26,720 --> 00:14:29,199
and so what we then go ahead and do is

406
00:14:29,199 --> 00:14:32,000
tell the module to get a global variable

407
00:14:32,000 --> 00:14:34,480
with the name function name plus

408
00:14:34,480 --> 00:14:36,720
function call variable name

409
00:14:36,720 --> 00:14:37,680
now

410
00:14:37,680 --> 00:14:38,959
here's the thing

411
00:14:38,959 --> 00:14:41,600
unlike this line over here if the global

412
00:14:41,600 --> 00:14:44,399
variable doesn't already exist it's not

413
00:14:44,399 --> 00:14:47,920
going to be inserted and so if this is a

414
00:14:47,920 --> 00:14:50,160
null pointer if this doesn't return to

415
00:14:50,160 --> 00:14:52,320
us an actual global variable we need to

416
00:14:52,320 --> 00:14:54,800
go ahead and create this global variable

417
00:14:54,800 --> 00:14:55,920
and then

418
00:14:55,920 --> 00:14:59,360
use it from there so what we do

419
00:14:59,360 --> 00:15:01,440
is if this is a null pointer we create a

420
00:15:01,440 --> 00:15:03,920
new global variable class instance we

421
00:15:03,920 --> 00:15:05,519
pass it the module that we're a part of

422
00:15:05,519 --> 00:15:07,279
so it knows where to insert the global

423
00:15:07,279 --> 00:15:09,279
variable we tell it that it needs to be

424
00:15:09,279 --> 00:15:11,360
a 32-bit integer type

425
00:15:11,360 --> 00:15:13,040
we go ahead and give it common linkage

426
00:15:13,040 --> 00:15:15,040
we give it a default static initializer

427
00:15:15,040 --> 00:15:18,079
value of zero and we give it the correct

428
00:15:18,079 --> 00:15:19,680
name

429
00:15:19,680 --> 00:15:20,959
now that i think about it technically

430
00:15:20,959 --> 00:15:22,959
since we're already appending call count

431
00:15:22,959 --> 00:15:24,639
we don't need to be doing it here once

432
00:15:24,639 --> 00:15:25,519
again

433
00:15:25,519 --> 00:15:27,440
we also then go ahead and once again set

434
00:15:27,440 --> 00:15:30,000
the initializer of function call count

435
00:15:30,000 --> 00:15:34,079
uh to a constant integer of zero right

436
00:15:34,079 --> 00:15:35,600
so we're just making sure that this

437
00:15:35,600 --> 00:15:38,320
value is set to zero by default

438
00:15:38,320 --> 00:15:39,680
now after we've gone ahead and created

439
00:15:39,680 --> 00:15:41,199
that global variable we can go ahead and

440
00:15:41,199 --> 00:15:42,800
actually start inserting some code this

441
00:15:42,800 --> 00:15:45,040
is the fun part so the first thing we do

442
00:15:45,040 --> 00:15:47,519
is i mean functions being effectively

443
00:15:47,519 --> 00:15:49,360
collections of instructions are

444
00:15:49,360 --> 00:15:52,720
iterators in c plus and so what we can

445
00:15:52,720 --> 00:15:54,480
do is go ahead and take a reference to

446
00:15:54,480 --> 00:15:56,240
the function that we've been passed and

447
00:15:56,240 --> 00:15:58,240
get the front which is the first you

448
00:15:58,240 --> 00:16:00,320
know thing in the iterator so get the

449
00:16:00,320 --> 00:16:01,920
first thing in the iterator and get the

450
00:16:01,920 --> 00:16:03,360
first thing from that because what it

451
00:16:03,360 --> 00:16:05,519
returns to us is also an iterator why is

452
00:16:05,519 --> 00:16:07,440
that well once again it's because llvm

453
00:16:07,440 --> 00:16:09,920
code is built up of basic blocks so

454
00:16:09,920 --> 00:16:11,759
you've got functions that consist of

455
00:16:11,759 --> 00:16:13,600
effectively an iterator of basic blocks

456
00:16:13,600 --> 00:16:15,279
each basic block is an iterator of

457
00:16:15,279 --> 00:16:17,040
instructions so what this is doing is

458
00:16:17,040 --> 00:16:18,720
it's getting the first basic block from

459
00:16:18,720 --> 00:16:20,800
the function and from the first basic

460
00:16:20,800 --> 00:16:23,440
block we get the first instruction this

461
00:16:23,440 --> 00:16:25,360
is the first instruction that is

462
00:16:25,360 --> 00:16:27,839
executed on the entry point to the

463
00:16:27,839 --> 00:16:29,680
function we then go ahead and create an

464
00:16:29,680 --> 00:16:32,320
ir builder instance on top of this first

465
00:16:32,320 --> 00:16:35,519
instruction enabling us to insert code

466
00:16:35,519 --> 00:16:39,600
just before this first instruction

467
00:16:39,600 --> 00:16:41,279
now what code do we want to insert you

468
00:16:41,279 --> 00:16:42,959
may ask well

469
00:16:42,959 --> 00:16:45,360
pretty simple we got to do a load add

470
00:16:45,360 --> 00:16:47,839
store operation what we have to do is we

471
00:16:47,839 --> 00:16:50,160
have to load the global variable that we

472
00:16:50,160 --> 00:16:53,040
created in the llvm module because if

473
00:16:53,040 --> 00:16:54,560
you think about it global variables kind

474
00:16:54,560 --> 00:16:56,880
of need to be pointers it doesn't really

475
00:16:56,880 --> 00:16:58,720
make all that much sense for there to be

476
00:16:58,720 --> 00:17:00,560
a global variable here that isn't a

477
00:17:00,560 --> 00:17:02,560
pointer so we have to load that pointer

478
00:17:02,560 --> 00:17:03,920
value

479
00:17:03,920 --> 00:17:06,000
from the global variable

480
00:17:06,000 --> 00:17:07,679
once we've loaded it

481
00:17:07,679 --> 00:17:10,160
we can go ahead and add one to that sort

482
00:17:10,160 --> 00:17:12,400
of local register value within the

483
00:17:12,400 --> 00:17:14,000
function right so we've loaded that

484
00:17:14,000 --> 00:17:15,679
memory address into the function to a

485
00:17:15,679 --> 00:17:19,360
local register we can add one to um that

486
00:17:19,360 --> 00:17:21,520
loaded value locally and then we can go

487
00:17:21,520 --> 00:17:24,880
ahead and store that new register value

488
00:17:24,880 --> 00:17:27,679
into the global variables memory address

489
00:17:27,679 --> 00:17:31,280
so once again llvmir is in ssa single

490
00:17:31,280 --> 00:17:33,600
static assignment form so we can't just

491
00:17:33,600 --> 00:17:35,520
say you know set the previous register

492
00:17:35,520 --> 00:17:37,600
to itself plus one we have to create a

493
00:17:37,600 --> 00:17:40,480
new ad instruction um that will run the

494
00:17:40,480 --> 00:17:43,679
ad and give us a new value register um

495
00:17:43,679 --> 00:17:45,600
that we will then go ahead and store in

496
00:17:45,600 --> 00:17:47,039
the memory in the existing memory

497
00:17:47,039 --> 00:17:48,240
address that we have for the global

498
00:17:48,240 --> 00:17:49,919
variable now

499
00:17:49,919 --> 00:17:51,760
even though llvm obviously has this

500
00:17:51,760 --> 00:17:54,320
infinite register architecture cpus

501
00:17:54,320 --> 00:17:56,720
don't and so llvm code is heavily

502
00:17:56,720 --> 00:17:59,120
optimized away when being translated to

503
00:17:59,120 --> 00:18:00,559
actual machine code

504
00:18:00,559 --> 00:18:02,000
um

505
00:18:02,000 --> 00:18:03,760
values aren't just kept around for no

506
00:18:03,760 --> 00:18:05,600
reason they're you know gotten rid of

507
00:18:05,600 --> 00:18:06,720
when you don't need them anymore that's

508
00:18:06,720 --> 00:18:09,039
sort of the advantage of the ssa format

509
00:18:09,039 --> 00:18:10,960
is it's very easy to determine these

510
00:18:10,960 --> 00:18:11,919
things

511
00:18:11,919 --> 00:18:14,559
uh then all we got to do uh is is sort

512
00:18:14,559 --> 00:18:16,880
of figure out what string it is that we

513
00:18:16,880 --> 00:18:19,440
want printf to actually print and in

514
00:18:19,440 --> 00:18:21,600
this case what i wanted to print is the

515
00:18:21,600 --> 00:18:25,280
function name plus uh or plus a space um

516
00:18:25,280 --> 00:18:26,720
and then the percent d which is the

517
00:18:26,720 --> 00:18:29,440
format specifier for a 32-bit integer

518
00:18:29,440 --> 00:18:31,840
and then a new line character the reason

519
00:18:31,840 --> 00:18:33,360
we want to do that is because the way

520
00:18:33,360 --> 00:18:36,799
we're going to invoke printf is with the

521
00:18:36,799 --> 00:18:39,919
number of calls as a separate argument

522
00:18:39,919 --> 00:18:43,760
so that we only need one string um for

523
00:18:43,760 --> 00:18:45,919
to invoke printf with and then from

524
00:18:45,919 --> 00:18:47,280
there we can just pass different

525
00:18:47,280 --> 00:18:49,200
arguments to printf in order to get it

526
00:18:49,200 --> 00:18:51,679
to print the different strings based off

527
00:18:51,679 --> 00:18:53,760
of the call count

528
00:18:53,760 --> 00:18:56,480
so i then go ahead and take this string

529
00:18:56,480 --> 00:18:58,080
of the function name plus the format

530
00:18:58,080 --> 00:19:00,720
specifier create another global variable

531
00:19:00,720 --> 00:19:03,200
out of that string and then we create a

532
00:19:03,200 --> 00:19:05,039
call instruction to the printf function

533
00:19:05,039 --> 00:19:08,400
that we created up here on line 24

534
00:19:08,400 --> 00:19:10,640
and we pass it two parameters we pass it

535
00:19:10,640 --> 00:19:12,559
the pointer to the string that contains

536
00:19:12,559 --> 00:19:13,919
you know what it is that we want printf

537
00:19:13,919 --> 00:19:16,320
to print of course and then the added

538
00:19:16,320 --> 00:19:18,720
call count which is this register over

539
00:19:18,720 --> 00:19:21,120
here that we're reusing after we used it

540
00:19:21,120 --> 00:19:24,799
for a store operation um in order to

541
00:19:24,799 --> 00:19:26,400
get it to

542
00:19:26,400 --> 00:19:28,640
print the call count after it's been

543
00:19:28,640 --> 00:19:30,080
incremented so we don't need to do

544
00:19:30,080 --> 00:19:32,799
another load we can just use the added

545
00:19:32,799 --> 00:19:35,120
value that we had then stored into the

546
00:19:35,120 --> 00:19:36,840
global variables memory

547
00:19:36,840 --> 00:19:39,039
address now from there of course there's

548
00:19:39,039 --> 00:19:40,720
just some pretty simple registration

549
00:19:40,720 --> 00:19:42,640
code effectively what this is doing is

550
00:19:42,640 --> 00:19:44,559
it's telling llvm

551
00:19:44,559 --> 00:19:46,960
how to call the function pass and the

552
00:19:46,960 --> 00:19:48,720
fact it's sort of registering the fact

553
00:19:48,720 --> 00:19:50,400
that it exists right so for example

554
00:19:50,400 --> 00:19:52,160
calling it to register pass with the

555
00:19:52,160 --> 00:19:54,480
structure that we created uh

556
00:19:54,480 --> 00:19:57,120
and some parameters here enables it to

557
00:19:57,120 --> 00:19:59,520
understand how to call the function pass

558
00:19:59,520 --> 00:20:02,080
in particular this argument for example

559
00:20:02,080 --> 00:20:04,320
is the actual command line flag you

560
00:20:04,320 --> 00:20:06,880
would need to pass to clang in order to

561
00:20:06,880 --> 00:20:08,720
invoke this function pass

562
00:20:08,720 --> 00:20:12,159
if you were to not pass dash rpfcc to

563
00:20:12,159 --> 00:20:14,159
clang when compiling it wouldn't

564
00:20:14,159 --> 00:20:16,400
actually use the function pass that you

565
00:20:16,400 --> 00:20:18,400
just built so let's go ahead and take a

566
00:20:18,400 --> 00:20:19,919
look at what it looks like to actually

567
00:20:19,919 --> 00:20:21,280
use it

568
00:20:21,280 --> 00:20:23,360
so the first thing i can do

569
00:20:23,360 --> 00:20:25,919
is go ahead and compile the actual

570
00:20:25,919 --> 00:20:27,120
function pass

571
00:20:27,120 --> 00:20:29,440
so all this is going to do is it's going

572
00:20:29,440 --> 00:20:32,400
to take the c plus code compile it

573
00:20:32,400 --> 00:20:35,280
and export it to a shared library now

574
00:20:35,280 --> 00:20:37,039
this shared library is something that

575
00:20:37,039 --> 00:20:39,039
you want to pass to clang or technically

576
00:20:39,039 --> 00:20:41,679
to llvm when it's compiling your code

577
00:20:41,679 --> 00:20:44,880
alongside the dash rpfcc flag and what

578
00:20:44,880 --> 00:20:46,880
that's going to do is when llvm is

579
00:20:46,880 --> 00:20:48,559
compiling it's going to load this shared

580
00:20:48,559 --> 00:20:50,960
library the static registration code at

581
00:20:50,960 --> 00:20:53,200
the end is going to execute telling llvm

582
00:20:53,200 --> 00:20:55,600
that exists and then when llvm sees your

583
00:20:55,600 --> 00:20:57,760
command line flag eventually it'll go

584
00:20:57,760 --> 00:20:59,520
back and realize that hey this flag is

585
00:20:59,520 --> 00:21:02,159
associated with this function pass and

586
00:21:02,159 --> 00:21:03,840
it will make sure that it's invoked at

587
00:21:03,840 --> 00:21:05,760
the right time

588
00:21:05,760 --> 00:21:08,960
and how convenient i've also got a

589
00:21:08,960 --> 00:21:11,600
little piece of example code here for us

590
00:21:11,600 --> 00:21:13,200
to check out

591
00:21:13,200 --> 00:21:16,080
this example code is very much a classic

592
00:21:16,080 --> 00:21:18,640
it's a simple factorial function uh that

593
00:21:18,640 --> 00:21:21,679
enables us uh to see how many times the

594
00:21:21,679 --> 00:21:23,120
and when we run this we'll be able to

595
00:21:23,120 --> 00:21:25,440
see how many times factorial and main

596
00:21:25,440 --> 00:21:26,960
are called all we're doing with this

597
00:21:26,960 --> 00:21:29,440
code is printing the factorial of 5

598
00:21:29,440 --> 00:21:31,600
recursively it's not particularly

599
00:21:31,600 --> 00:21:33,200
complex

600
00:21:33,200 --> 00:21:35,200
if i were to compile this normally which

601
00:21:35,200 --> 00:21:37,039
of course is possible

602
00:21:37,039 --> 00:21:39,520
we'll just see 120 which is indeed 5

603
00:21:39,520 --> 00:21:41,120
factorial

604
00:21:41,120 --> 00:21:43,280
so as you can see that does work now

605
00:21:43,280 --> 00:21:45,039
i've got a bit of a build script ready

606
00:21:45,039 --> 00:21:46,799
here and the build script really just

607
00:21:46,799 --> 00:21:50,559
has three steps the first one is to take

608
00:21:50,559 --> 00:21:53,280
factorial.c and compile it to another

609
00:21:53,280 --> 00:21:55,520
file called factorial.ll

610
00:21:55,520 --> 00:21:58,159
ll is the file extension for llvm ir

611
00:21:58,159 --> 00:21:59,919
code and if we take a look at it we can

612
00:21:59,919 --> 00:22:03,120
actually see what llvmir the c code

613
00:22:03,120 --> 00:22:05,120
translates to as you can see it's kind

614
00:22:05,120 --> 00:22:06,799
of understandable and readable as to

615
00:22:06,799 --> 00:22:08,799
what it's trying to do but it's very

616
00:22:08,799 --> 00:22:10,960
clearly not high level right it still

617
00:22:10,960 --> 00:22:13,039
does require some analysis to really

618
00:22:13,039 --> 00:22:14,640
understand what's going on

619
00:22:14,640 --> 00:22:16,720
but overall it's better than assembly

620
00:22:16,720 --> 00:22:18,320
and it's not architecture specific so

621
00:22:18,320 --> 00:22:19,679
that's a plus

622
00:22:19,679 --> 00:22:21,360
now what we want to do is we somehow

623
00:22:21,360 --> 00:22:24,720
want to modify this llvm ir code um

624
00:22:24,720 --> 00:22:27,200
using the llvm opt utility what we're

625
00:22:27,200 --> 00:22:28,320
going to do is we're going to tell the

626
00:22:28,320 --> 00:22:32,320
opt utility to load this um

627
00:22:32,320 --> 00:22:34,720
this shared library that we compiled our

628
00:22:34,720 --> 00:22:36,559
function pass into and then we're going

629
00:22:36,559 --> 00:22:38,720
to pass it the flag to actually invoke

630
00:22:38,720 --> 00:22:40,600
that pass and we're going to pass it

631
00:22:40,600 --> 00:22:43,360
factorial.ll and tell it to once again

632
00:22:43,360 --> 00:22:46,960
output llvmir uh to a new file called

633
00:22:46,960 --> 00:22:49,200
factorialopt.ll

634
00:22:49,200 --> 00:22:51,360
now if we take a look at this code as

635
00:22:51,360 --> 00:22:52,840
you can see there have been some

636
00:22:52,840 --> 00:22:55,520
modifications completely automatically

637
00:22:55,520 --> 00:22:57,360
some of these modifications include the

638
00:22:57,360 --> 00:23:00,080
addition of these four global variables

639
00:23:00,080 --> 00:23:01,919
factorial call count which is how many

640
00:23:01,919 --> 00:23:03,360
times the factorial function's been

641
00:23:03,360 --> 00:23:05,840
called main call count which is the same

642
00:23:05,840 --> 00:23:08,080
thing but for main as well as these two

643
00:23:08,080 --> 00:23:10,799
unnamed global variables 0 and 1 that

644
00:23:10,799 --> 00:23:12,960
are used as the actual format strings

645
00:23:12,960 --> 00:23:15,120
for printf to know how to print the

646
00:23:15,120 --> 00:23:17,360
names of factorial and main as well as

647
00:23:17,360 --> 00:23:20,159
their call counts as you can see in the

648
00:23:20,159 --> 00:23:22,080
sort of beginning of the factorial

649
00:23:22,080 --> 00:23:24,080
function we've added four instructions

650
00:23:24,080 --> 00:23:26,000
we've added a load of the global call

651
00:23:26,000 --> 00:23:28,559
count variable and add to it a store

652
00:23:28,559 --> 00:23:31,679
back to it and a call to printf to tell

653
00:23:31,679 --> 00:23:33,600
it to actually do what we wanted to do

654
00:23:33,600 --> 00:23:36,080
print the function call

655
00:23:36,080 --> 00:23:38,240
from there we also see very similar

656
00:23:38,240 --> 00:23:41,679
additions to the main function and that

657
00:23:41,679 --> 00:23:44,240
is what our function pass just did if i

658
00:23:44,240 --> 00:23:46,080
were to go ahead and quit here i can now

659
00:23:46,080 --> 00:23:48,840
run this final clang command to take the

660
00:23:48,840 --> 00:23:51,919
llvmir and output an actual binary from

661
00:23:51,919 --> 00:23:53,120
it and

662
00:23:53,120 --> 00:23:55,440
theoretically we should see the

663
00:23:55,440 --> 00:23:57,279
following printed out

664
00:23:57,279 --> 00:24:00,000
with the exact same c code with no code

665
00:24:00,000 --> 00:24:02,080
modifications to the actual original

666
00:24:02,080 --> 00:24:04,240
source we're now getting it to do

667
00:24:04,240 --> 00:24:06,400
something different in this case it was

668
00:24:06,400 --> 00:24:08,320
a very simple function pass that enabled

669
00:24:08,320 --> 00:24:11,120
us to print out a function name and what

670
00:24:11,120 --> 00:24:13,039
iteration it's on how many times it has

671
00:24:13,039 --> 00:24:15,520
been called up until that point as you

672
00:24:15,520 --> 00:24:17,039
can see because we're calculating the

673
00:24:17,039 --> 00:24:19,440
factorial of 5 it goes up to 5 4

674
00:24:19,440 --> 00:24:22,400
factorial since it's recursive

675
00:24:22,400 --> 00:24:24,559
however what's beautiful about this

676
00:24:24,559 --> 00:24:25,679
technique is that you can do whatever

677
00:24:25,679 --> 00:24:27,440
you want right it doesn't even need to

678
00:24:27,440 --> 00:24:29,440
modify the code you could do you know

679
00:24:29,440 --> 00:24:31,919
static analysis of your code at compile

680
00:24:31,919 --> 00:24:34,000
time and just log out stats you could

681
00:24:34,000 --> 00:24:36,720
log out um information that helps you

682
00:24:36,720 --> 00:24:38,400
later determine code coverage of your

683
00:24:38,400 --> 00:24:40,640
tests you could insert code that helps

684
00:24:40,640 --> 00:24:42,400
you instrument how long functions take

685
00:24:42,400 --> 00:24:45,360
to run you could insert a code that does

686
00:24:45,360 --> 00:24:47,360
quite literally anything you want it to

687
00:24:47,360 --> 00:24:50,000
at compile time and because it's llvm

688
00:24:50,000 --> 00:24:52,159
based it works across a variety of

689
00:24:52,159 --> 00:24:54,240
different languages right one llvm

690
00:24:54,240 --> 00:24:56,559
function pass has the opportunity to

691
00:24:56,559 --> 00:25:00,880
work across swift rust julia c c plus

692
00:25:00,880 --> 00:25:03,760
plus fortran and even more code right

693
00:25:03,760 --> 00:25:05,120
and

694
00:25:05,120 --> 00:25:07,120
i mean technically some can require a

695
00:25:07,120 --> 00:25:09,039
few more tweaks like for example some

696
00:25:09,039 --> 00:25:10,960
libraries will compile one of your

697
00:25:10,960 --> 00:25:13,120
functions to multiple lvm functions or

698
00:25:13,120 --> 00:25:15,120
they'll just make longer or more messed

699
00:25:15,120 --> 00:25:17,360
up functions in a way in llvm but it is

700
00:25:17,360 --> 00:25:19,200
still possible right with very little

701
00:25:19,200 --> 00:25:21,919
tweaking across languages and that is

702
00:25:21,919 --> 00:25:24,240
what's so beautiful about the llvm

703
00:25:24,240 --> 00:25:26,000
infrastructure and is why i am so

704
00:25:26,000 --> 00:25:27,919
passionate about not only compilers in

705
00:25:27,919 --> 00:25:30,640
general but particularly how to use this

706
00:25:30,640 --> 00:25:32,880
tooling because i believe it is the best

707
00:25:32,880 --> 00:25:35,679
way to be able to build compilers for

708
00:25:35,679 --> 00:25:38,159
the future in a way that is scalable and

709
00:25:38,159 --> 00:25:40,799
enables sharing of resources and ideas

710
00:25:40,799 --> 00:25:43,440
across so many different communities it

711
00:25:43,440 --> 00:25:46,559
is honestly pretty fascinating to see

712
00:25:46,559 --> 00:25:48,480
and that is how you build simple llvm

713
00:25:48,480 --> 00:25:50,720
function passes in c plus once again i

714
00:25:50,720 --> 00:25:52,159
do hope you enjoyed if you did please do

715
00:25:52,159 --> 00:25:54,000
make sure to like the video subscribe to

716
00:25:54,000 --> 00:25:55,919
the channel turn on notifications and of

717
00:25:55,919 --> 00:25:57,360
course once again any questions

718
00:25:57,360 --> 00:25:59,039
suggestions or feedback please do leave

719
00:25:59,039 --> 00:26:00,720
it down in the comment section below i

720
00:26:00,720 --> 00:26:02,720
would love to hear from you if you'd

721
00:26:02,720 --> 00:26:04,960
like to see more tutorials on llvm how

722
00:26:04,960 --> 00:26:06,799
to build your own passes if you have any

723
00:26:06,799 --> 00:26:08,400
particular ideas of things you'd like to

724
00:26:08,400 --> 00:26:10,480
see me build or if you'd like me to go

725
00:26:10,480 --> 00:26:11,919
ahead and build similar things in other

726
00:26:11,919 --> 00:26:14,159
languages like roster swift let me know

727
00:26:14,159 --> 00:26:16,240
and i will get on that but once again

728
00:26:16,240 --> 00:26:17,840
thank you very much for joining today

729
00:26:17,840 --> 00:26:21,120
and goodbye
