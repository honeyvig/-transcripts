1
00:00:00,320 --> 00:00:02,159
so hello there and welcome to another

2
00:00:02,159 --> 00:00:04,400
tutorial my name is tammy bakshi and

3
00:00:04,400 --> 00:00:05,040
today

4
00:00:05,040 --> 00:00:06,960
we're going to be going over how you can

5
00:00:06,960 --> 00:00:09,040
implement and optimize

6
00:00:09,040 --> 00:00:12,240
a proof of work algorithm on gpu

7
00:00:12,240 --> 00:00:14,480
using cuda now this is really

8
00:00:14,480 --> 00:00:15,280
interesting

9
00:00:15,280 --> 00:00:17,440
because we're gonna go from just being

10
00:00:17,440 --> 00:00:19,680
able to process a few hundred million

11
00:00:19,680 --> 00:00:21,840
hashes per second on cpu

12
00:00:21,840 --> 00:00:24,880
to now being able to process over eight

13
00:00:24,880 --> 00:00:28,080
billion hashes per second on four

14
00:00:28,080 --> 00:00:31,199
nvidia tesla v100 gpus

15
00:00:31,199 --> 00:00:33,040
now before we get deeper into this whole

16
00:00:33,040 --> 00:00:34,800
proof of work stuff there's one more

17
00:00:34,800 --> 00:00:35,760
thing that i want to say

18
00:00:35,760 --> 00:00:37,520
today we are going to be taking a look

19
00:00:37,520 --> 00:00:39,200
at what are what are known as

20
00:00:39,200 --> 00:00:41,680
cuda kernels so writing code that's

21
00:00:41,680 --> 00:00:44,000
going to run on your gpu to run

22
00:00:44,000 --> 00:00:45,920
again what's known as an embarrassingly

23
00:00:45,920 --> 00:00:47,840
parallel task that's the technical term

24
00:00:47,840 --> 00:00:48,960
so if you'd like to learn about the

25
00:00:48,960 --> 00:00:50,960
fundamentals of cuda kernels and how

26
00:00:50,960 --> 00:00:51,680
they work

27
00:00:51,680 --> 00:00:53,520
there is a youtube video that i recorded

28
00:00:53,520 --> 00:00:54,960
a couple of years ago

29
00:00:54,960 --> 00:00:57,199
on the world of cuda and the basics of

30
00:00:57,199 --> 00:00:58,000
how you can implement

31
00:00:58,000 --> 00:01:00,879
some simple vector mathematics on cuda

32
00:01:00,879 --> 00:01:01,520
chips

33
00:01:01,520 --> 00:01:03,280
but today we're going to be taking those

34
00:01:03,280 --> 00:01:05,119
concepts and scaling them even further

35
00:01:05,119 --> 00:01:06,880
so there is a link on screen right now

36
00:01:06,880 --> 00:01:08,880
where you can go ahead and take a look

37
00:01:08,880 --> 00:01:10,479
at that previous tutorial if you'd like

38
00:01:10,479 --> 00:01:12,000
to find out the fundamentals of cuda

39
00:01:12,000 --> 00:01:14,320
kernels so hello there and welcome to

40
00:01:14,320 --> 00:01:15,759
another tutorial

41
00:01:15,759 --> 00:01:17,840
my name is tammy bakshi and this time

42
00:01:17,840 --> 00:01:19,119
we're going to be going over

43
00:01:19,119 --> 00:01:22,080
how you can use cuda c for general

44
00:01:22,080 --> 00:01:22,640
purpose

45
00:01:22,640 --> 00:01:25,040
gpu computing and of course if you'd

46
00:01:25,040 --> 00:01:26,720
like to be notified whenever i release

47
00:01:26,720 --> 00:01:28,080
new content like this one

48
00:01:28,080 --> 00:01:29,680
please do feel free to subscribe to the

49
00:01:29,680 --> 00:01:31,280
channel ring the notification bell and

50
00:01:31,280 --> 00:01:32,640
that way you'll know when i release a

51
00:01:32,640 --> 00:01:33,280
new video

52
00:01:33,280 --> 00:01:35,600
on a topic just like this one now this

53
00:01:35,600 --> 00:01:36,720
is absolutely

54
00:01:36,720 --> 00:01:39,040
fascinating stuff and what do these

55
00:01:39,040 --> 00:01:40,640
numbers mean well first of all

56
00:01:40,640 --> 00:01:42,079
we'd have to understand what a

57
00:01:42,079 --> 00:01:44,399
proof-of-work algorithm really is

58
00:01:44,399 --> 00:01:46,960
now a proof-of-work algorithm on its own

59
00:01:46,960 --> 00:01:48,079
doesn't really mean

60
00:01:48,079 --> 00:01:50,240
much it's just an algorithm where you're

61
00:01:50,240 --> 00:01:52,000
trying to brute force a certain

62
00:01:52,000 --> 00:01:55,040
hash condition however when you apply

63
00:01:55,040 --> 00:01:57,119
this proof of work to another algorithm

64
00:01:57,119 --> 00:01:58,000
like for example

65
00:01:58,000 --> 00:02:00,320
the blockchain network then you get

66
00:02:00,320 --> 00:02:02,079
something that's really useful

67
00:02:02,079 --> 00:02:04,240
by using the proof of work technique

68
00:02:04,240 --> 00:02:05,520
blockchains can actually

69
00:02:05,520 --> 00:02:07,439
verify transactions in a completely

70
00:02:07,439 --> 00:02:08,959
decentralized way

71
00:02:08,959 --> 00:02:11,200
meaning there's no centralized server

72
00:02:11,200 --> 00:02:13,440
where all those transactions are stored

73
00:02:13,440 --> 00:02:15,040
this is really interesting stuff but

74
00:02:15,040 --> 00:02:17,200
again what does proof of work

75
00:02:17,200 --> 00:02:19,680
actually mean well let's take a look

76
00:02:19,680 --> 00:02:20,879
first of all it's important to

77
00:02:20,879 --> 00:02:22,400
understand the concept of a hash

78
00:02:22,400 --> 00:02:23,040
function

79
00:02:23,040 --> 00:02:25,040
i won't get deep into exactly how they

80
00:02:25,040 --> 00:02:26,720
work but there's a series of hash

81
00:02:26,720 --> 00:02:27,840
functions called the

82
00:02:27,840 --> 00:02:31,200
sha hasp hash functions this sha 1 2

83
00:02:31,200 --> 00:02:34,000
and 3. shot 2 in specific was developed

84
00:02:34,000 --> 00:02:35,280
by the cia

85
00:02:35,280 --> 00:02:36,800
and it's what's known as a

86
00:02:36,800 --> 00:02:38,400
cryptographically secure

87
00:02:38,400 --> 00:02:40,400
hashing function so what that means is

88
00:02:40,400 --> 00:02:42,400
we can feed in as much data as we like

89
00:02:42,400 --> 00:02:43,519
into shot

90
00:02:43,519 --> 00:02:46,160
shot 2 and it's going to output a series

91
00:02:46,160 --> 00:02:47,200
of bytes

92
00:02:47,200 --> 00:02:49,360
and these bytes are what's known as a

93
00:02:49,360 --> 00:02:51,599
digest of the information that was fed

94
00:02:51,599 --> 00:02:52,560
in

95
00:02:52,560 --> 00:02:54,800
now the length of those bytes is limited

96
00:02:54,800 --> 00:02:55,680
so for example

97
00:02:55,680 --> 00:02:58,159
sha 256 which is the most popular

98
00:02:58,159 --> 00:02:59,519
hashing algorithm under

99
00:02:59,519 --> 00:03:04,080
under the shaw family will output 256

100
00:03:04,080 --> 00:03:07,680
bits of info or 32 bytes of info

101
00:03:07,680 --> 00:03:10,239
now here's the thing about sha-256

102
00:03:10,239 --> 00:03:12,239
because we can only represent 2 to the

103
00:03:12,239 --> 00:03:14,159
power 256

104
00:03:14,159 --> 00:03:16,480
total possible hashes it's always

105
00:03:16,480 --> 00:03:18,159
possible that two completely

106
00:03:18,159 --> 00:03:20,720
separate inputs will end up having the

107
00:03:20,720 --> 00:03:21,680
same hash

108
00:03:21,680 --> 00:03:23,879
but the likelihood of that is

109
00:03:23,879 --> 00:03:25,840
exorbitantly small it's

110
00:03:25,840 --> 00:03:28,400
essentially infinitesimal because of

111
00:03:28,400 --> 00:03:31,760
course we have 2 to the power 256

112
00:03:31,760 --> 00:03:34,159
possible hashes i mean if you were to

113
00:03:34,159 --> 00:03:34,799
feed in

114
00:03:34,799 --> 00:03:37,440
a couple million bytes and even just one

115
00:03:37,440 --> 00:03:38,400
of them changed

116
00:03:38,400 --> 00:03:40,480
slightly by a single bit you would most

117
00:03:40,480 --> 00:03:42,239
likely get a completely

118
00:03:42,239 --> 00:03:44,799
different hash the entire idea of a

119
00:03:44,799 --> 00:03:45,760
hashing algorithm

120
00:03:45,760 --> 00:03:47,920
is that you cannot go from output to

121
00:03:47,920 --> 00:03:49,280
input only

122
00:03:49,280 --> 00:03:52,560
input to output now paradoxically in a

123
00:03:52,560 --> 00:03:53,200
way

124
00:03:53,200 --> 00:03:55,040
a hashing algorithm is more

125
00:03:55,040 --> 00:03:56,879
cryptographically secure

126
00:03:56,879 --> 00:03:59,840
if it takes longer to compute because if

127
00:03:59,840 --> 00:04:01,439
it takes longer to compute

128
00:04:01,439 --> 00:04:03,280
then it's harder to brute force that

129
00:04:03,280 --> 00:04:04,480
algorithm

130
00:04:04,480 --> 00:04:06,239
with cryptocurrency mining people have

131
00:04:06,239 --> 00:04:08,000
come up with all sorts of creative ways

132
00:04:08,000 --> 00:04:09,920
to get really really fast hashers in

133
00:04:09,920 --> 00:04:12,400
order to gain as much crypto as possible

134
00:04:12,400 --> 00:04:14,000
like for example asics that i'm sure

135
00:04:14,000 --> 00:04:15,760
you've heard about but today what we're

136
00:04:15,760 --> 00:04:16,799
going to be doing

137
00:04:16,799 --> 00:04:18,639
is quite interesting we're going to take

138
00:04:18,639 --> 00:04:20,320
an input string so for example

139
00:04:20,320 --> 00:04:22,880
to make sheet and we're going to try and

140
00:04:22,880 --> 00:04:24,960
find a sequence of 20

141
00:04:24,960 --> 00:04:27,520
characters that when appended to the

142
00:04:27,520 --> 00:04:28,880
input string

143
00:04:28,880 --> 00:04:32,639
in total result in a sha-256 hash

144
00:04:32,639 --> 00:04:35,199
where the first n number of bytes are

145
00:04:35,199 --> 00:04:36,560
totally zeros

146
00:04:36,560 --> 00:04:38,639
and so for example maybe we want to find

147
00:04:38,639 --> 00:04:40,560
a certain sequence of 20 characters

148
00:04:40,560 --> 00:04:42,240
where when you take the input and append

149
00:04:42,240 --> 00:04:44,240
it the first three bytes of the hash are

150
00:04:44,240 --> 00:04:45,600
all zeros

151
00:04:45,600 --> 00:04:47,600
now you might think why would you want

152
00:04:47,600 --> 00:04:48,800
to do that

153
00:04:48,800 --> 00:04:50,639
well you don't really need to do that

154
00:04:50,639 --> 00:04:52,800
for anything but what that proves

155
00:04:52,800 --> 00:04:55,040
is that your computer has done the work

156
00:04:55,040 --> 00:04:56,720
to find those zeros

157
00:04:56,720 --> 00:04:59,040
and thereby in a blockchain you could

158
00:04:59,040 --> 00:04:59,759
use that

159
00:04:59,759 --> 00:05:02,240
work in order to prove that you verified

160
00:05:02,240 --> 00:05:04,479
a certain number of transactions

161
00:05:04,479 --> 00:05:07,120
and so that is how blockchain technology

162
00:05:07,120 --> 00:05:07,919
works

163
00:05:07,919 --> 00:05:09,360
and today we're going to be taking a

164
00:05:09,360 --> 00:05:10,960
look at how you can implement that proof

165
00:05:10,960 --> 00:05:12,240
of work algorithm

166
00:05:12,240 --> 00:05:14,560
now hashing is something that's very

167
00:05:14,560 --> 00:05:16,160
embarrassingly parallel is what the

168
00:05:16,160 --> 00:05:17,280
technical term is

169
00:05:17,280 --> 00:05:19,600
what that means is we can spin up

170
00:05:19,600 --> 00:05:21,360
thousands of threads on a certain

171
00:05:21,360 --> 00:05:22,000
machine

172
00:05:22,000 --> 00:05:24,400
that are all working to just generate

173
00:05:24,400 --> 00:05:25,360
random strings

174
00:05:25,360 --> 00:05:27,440
hash and check if it meets the condition

175
00:05:27,440 --> 00:05:29,440
because there's no logic involved

176
00:05:29,440 --> 00:05:31,360
you can't reverse engineer a hashing

177
00:05:31,360 --> 00:05:33,280
function the entire assumption of a

178
00:05:33,280 --> 00:05:34,960
hashing function is that you can't do

179
00:05:34,960 --> 00:05:36,800
that reverse engineering

180
00:05:36,800 --> 00:05:38,479
and so we have to essentially generate

181
00:05:38,479 --> 00:05:40,560
random strings and brute force

182
00:05:40,560 --> 00:05:44,080
check potentially trillions of hashes in

183
00:05:44,080 --> 00:05:46,000
order to find the right one

184
00:05:46,000 --> 00:05:48,880
and so on cpu this can be difficult

185
00:05:48,880 --> 00:05:49,759
because even the

186
00:05:49,759 --> 00:05:53,600
top of the line 128 thread ibm power

187
00:05:53,600 --> 00:05:54,560
servers

188
00:05:54,560 --> 00:05:56,479
can only process about 100 million

189
00:05:56,479 --> 00:05:58,080
hashes per second in fact

190
00:05:58,080 --> 00:05:59,680
if you want to take a look at how i

191
00:05:59,680 --> 00:06:01,919
actually implemented a cpu-based version

192
00:06:01,919 --> 00:06:03,280
of this do take a look at the live

193
00:06:03,280 --> 00:06:04,319
stream that i held

194
00:06:04,319 --> 00:06:07,520
on wednesday june 17 in order to

195
00:06:07,520 --> 00:06:10,240
implement a cpu-based hasher it was a

196
00:06:10,240 --> 00:06:11,600
live stream so you can actually take a

197
00:06:11,600 --> 00:06:13,199
look at the whole process of how we went

198
00:06:13,199 --> 00:06:13,680
through

199
00:06:13,680 --> 00:06:15,520
the idea of architecting and

200
00:06:15,520 --> 00:06:17,520
implementing that cpu-based hasher

201
00:06:17,520 --> 00:06:21,039
in golang and now in c as well

202
00:06:21,039 --> 00:06:23,759
however we cannot make do with only a

203
00:06:23,759 --> 00:06:25,680
couple hundred million hashes per second

204
00:06:25,680 --> 00:06:26,800
we've got to go

205
00:06:26,800 --> 00:06:28,960
even faster which is why we're going to

206
00:06:28,960 --> 00:06:31,039
be implementing on gpu for about eight

207
00:06:31,039 --> 00:06:33,440
billion hashes per second now that's

208
00:06:33,440 --> 00:06:34,479
even then

209
00:06:34,479 --> 00:06:35,840
a little bit slow because then with

210
00:06:35,840 --> 00:06:37,759
crypto mining you want in the trillions

211
00:06:37,759 --> 00:06:40,240
or quadrillions per second

212
00:06:40,240 --> 00:06:42,720
if you want to earn any money but for an

213
00:06:42,720 --> 00:06:44,319
application like this one

214
00:06:44,319 --> 00:06:46,240
under the constraints that we have for

215
00:06:46,240 --> 00:06:48,160
our solution it's absolutely more than

216
00:06:48,160 --> 00:06:49,919
enough now in case you're into this sort

217
00:06:49,919 --> 00:06:50,560
of stuff

218
00:06:50,560 --> 00:06:53,360
when i actually ran the cuda profiler to

219
00:06:53,360 --> 00:06:54,240
figure out how

220
00:06:54,240 --> 00:06:57,360
fast the solution is the compute speed

221
00:06:57,360 --> 00:06:57,919
of light

222
00:06:57,919 --> 00:06:59,759
score for this application was

223
00:06:59,759 --> 00:07:01,520
approximately 75

224
00:07:01,520 --> 00:07:03,840
so i am actually using a lot of the

225
00:07:03,840 --> 00:07:05,120
compute on the gpu

226
00:07:05,120 --> 00:07:07,520
and i've tried to minimize the overhead

227
00:07:07,520 --> 00:07:09,280
as much as possible

228
00:07:09,280 --> 00:07:11,840
uh enabling as few memory writes and

229
00:07:11,840 --> 00:07:13,759
reads as possible enabling as much data

230
00:07:13,759 --> 00:07:14,639
to be stored in

231
00:07:14,639 --> 00:07:16,960
in gpu registers and all these sorts of

232
00:07:16,960 --> 00:07:18,960
really intense optimizations to get

233
00:07:18,960 --> 00:07:21,120
to eight billion hashes per second and

234
00:07:21,120 --> 00:07:23,120
now i would love to show you exactly how

235
00:07:23,120 --> 00:07:24,720
those kuda kernels work

236
00:07:24,720 --> 00:07:26,400
and how you can build them for yourself

237
00:07:26,400 --> 00:07:28,000
and so without any further ado

238
00:07:28,000 --> 00:07:29,440
let's go ahead and take a look at how

239
00:07:29,440 --> 00:07:31,440
you can implement this on an ibm power

240
00:07:31,440 --> 00:07:32,720
server with four

241
00:07:32,720 --> 00:07:34,960
tesla v100 gpus in a totally scalable

242
00:07:34,960 --> 00:07:37,039
way it works on multiple gpus

243
00:07:37,039 --> 00:07:38,720
you can just tell it how many gpus you

244
00:07:38,720 --> 00:07:40,639
want to run on and all these other sorts

245
00:07:40,639 --> 00:07:42,400
of hyper parameters so let's take a look

246
00:07:42,400 --> 00:07:44,080
at how you can implement proof of work

247
00:07:44,080 --> 00:07:46,479
on cuda alright so now let's get started

248
00:07:46,479 --> 00:07:47,840
with taking a look at how the

249
00:07:47,840 --> 00:07:49,120
implementation

250
00:07:49,120 --> 00:07:51,440
of this proof-of-work algorithm works on

251
00:07:51,440 --> 00:07:53,360
cuda now as you can see i've already

252
00:07:53,360 --> 00:07:54,160
sshed

253
00:07:54,160 --> 00:07:57,440
into a server this is a power server

254
00:07:57,440 --> 00:07:59,199
so it's using an ibm power architecture

255
00:07:59,199 --> 00:08:01,440
not x86 so what's incredible about cuda

256
00:08:01,440 --> 00:08:02,319
is that of course

257
00:08:02,319 --> 00:08:04,080
it is completely cross-platform it even

258
00:08:04,080 --> 00:08:06,080
works on ibm power servers in fact it's

259
00:08:06,080 --> 00:08:06,479
better

260
00:08:06,479 --> 00:08:08,720
on power servers because of nv-link

261
00:08:08,720 --> 00:08:10,000
enabling really

262
00:08:10,000 --> 00:08:12,720
really great memory bandwidth enabling

263
00:08:12,720 --> 00:08:14,400
the cpu and gpu to talk

264
00:08:14,400 --> 00:08:16,879
super quickly now that doesn't really

265
00:08:16,879 --> 00:08:19,360
play into this use case in specific

266
00:08:19,360 --> 00:08:20,879
however for deep neural networks and

267
00:08:20,879 --> 00:08:23,039
these sorts of things power is great

268
00:08:23,039 --> 00:08:25,840
now as you can see on me over here i've

269
00:08:25,840 --> 00:08:26,240
got

270
00:08:26,240 --> 00:08:29,520
four uh nvidia tesla v100 gpus

271
00:08:29,520 --> 00:08:31,440
these gpus are not being used at all

272
00:08:31,440 --> 00:08:33,200
currently they're completely

273
00:08:33,200 --> 00:08:36,159
free to use um and what that means is

274
00:08:36,159 --> 00:08:37,360
that there's nothing else running on

275
00:08:37,360 --> 00:08:38,800
them so we're only going to be running

276
00:08:38,800 --> 00:08:41,360
the proof of work algorithm i have also

277
00:08:41,360 --> 00:08:42,880
gone into my home folder

278
00:08:42,880 --> 00:08:44,640
into a folder called redesigntrain which

279
00:08:44,640 --> 00:08:46,880
is just the name that github assigned

280
00:08:46,880 --> 00:08:48,320
this git repository

281
00:08:48,320 --> 00:08:51,200
um if you take a look this is a this is

282
00:08:51,200 --> 00:08:53,760
a github

283
00:08:53,760 --> 00:08:56,000
this is a git repo and so you can find

284
00:08:56,000 --> 00:08:58,160
this on the redesigned train repo on

285
00:08:58,160 --> 00:09:00,959
github link of course in the description

286
00:09:00,959 --> 00:09:02,880
uh now the way this works there are a

287
00:09:02,880 --> 00:09:04,320
couple different files here you don't

288
00:09:04,320 --> 00:09:06,560
need to worry about a.out right now all

289
00:09:06,560 --> 00:09:07,760
you need to worry about

290
00:09:07,760 --> 00:09:12,560
is the new.cu and and sha256.cuh files

291
00:09:12,560 --> 00:09:15,440
uh the new.cu file is the main file that

292
00:09:15,440 --> 00:09:16,560
we want to care about

293
00:09:16,560 --> 00:09:19,519
i i guess nu.cou could be like a main.c

294
00:09:19,519 --> 00:09:20,000
file

295
00:09:20,000 --> 00:09:23,360
and shot256.cuh would be a main.h or

296
00:09:23,360 --> 00:09:25,040
or just a header file that we want to

297
00:09:25,040 --> 00:09:26,480
include um

298
00:09:26,480 --> 00:09:28,720
now this header file is doing more than

299
00:09:28,720 --> 00:09:30,480
a traditional header file it actually

300
00:09:30,480 --> 00:09:31,200
has

301
00:09:31,200 --> 00:09:32,720
essentially all of the code for the

302
00:09:32,720 --> 00:09:34,480
sha-256 algorithm

303
00:09:34,480 --> 00:09:37,200
and this runs on the actual gpu so these

304
00:09:37,200 --> 00:09:40,000
are device functions a device function

305
00:09:40,000 --> 00:09:42,080
is a function that runs on the gpu once

306
00:09:42,080 --> 00:09:44,160
again cuda has very c like syntax in

307
00:09:44,160 --> 00:09:44,800
fact it

308
00:09:44,800 --> 00:09:48,640
uses c compilers in the back end

309
00:09:48,640 --> 00:09:50,560
and so that's that's the sha 256

310
00:09:50,560 --> 00:09:52,000
implementation i did not

311
00:09:52,000 --> 00:09:54,240
write that sha-256 implementation from

312
00:09:54,240 --> 00:09:55,040
scratch

313
00:09:55,040 --> 00:09:57,440
i modified it to fit this use case and i

314
00:09:57,440 --> 00:09:59,279
will be linking to the original

315
00:09:59,279 --> 00:10:01,360
implementation in the description as

316
00:10:01,360 --> 00:10:02,320
well

317
00:10:02,320 --> 00:10:04,000
but now let's go ahead and dive right

318
00:10:04,000 --> 00:10:07,440
into new dot coo

319
00:10:07,440 --> 00:10:09,680
now essentially what i want to start off

320
00:10:09,680 --> 00:10:10,560
by doing is

321
00:10:10,560 --> 00:10:12,720
describing the high level architecture

322
00:10:12,720 --> 00:10:14,160
of the program because i feel like

323
00:10:14,160 --> 00:10:15,600
that's a lot more important than the

324
00:10:15,600 --> 00:10:16,800
nitty gritty of how

325
00:10:16,800 --> 00:10:19,120
exactly everything communicates so let's

326
00:10:19,120 --> 00:10:20,720
go ahead and start off with the high

327
00:10:20,720 --> 00:10:22,079
level architecture

328
00:10:22,079 --> 00:10:25,760
now remember gpus are fast

329
00:10:25,760 --> 00:10:28,079
individually instruction for instruction

330
00:10:28,079 --> 00:10:30,160
they may be slower than a cpu

331
00:10:30,160 --> 00:10:33,120
but if you can run like thousands of

332
00:10:33,120 --> 00:10:33,680
different

333
00:10:33,680 --> 00:10:36,720
hash brew forcings per per you know

334
00:10:36,720 --> 00:10:38,079
clock cycle if you can run

335
00:10:38,079 --> 00:10:40,160
thousands of them instead of just a

336
00:10:40,160 --> 00:10:42,320
couple like you could on a cpu

337
00:10:42,320 --> 00:10:45,519
that means gpus are fast in fact they

338
00:10:45,519 --> 00:10:46,240
are so

339
00:10:46,240 --> 00:10:48,640
fast that they usually sort of reverse

340
00:10:48,640 --> 00:10:50,560
the traditional bottleneck

341
00:10:50,560 --> 00:10:53,040
usually your bottleneck is in compute

342
00:10:53,040 --> 00:10:54,959
because compute takes a long time

343
00:10:54,959 --> 00:10:57,920
and things like creating data or loading

344
00:10:57,920 --> 00:10:58,560
data

345
00:10:58,560 --> 00:11:01,360
aren't usually the bottlenecks however

346
00:11:01,360 --> 00:11:01,839
with

347
00:11:01,839 --> 00:11:04,160
gpu compute that gets turned around on

348
00:11:04,160 --> 00:11:06,160
its head as a matter of fact the gpus

349
00:11:06,160 --> 00:11:07,440
are so fast

350
00:11:07,440 --> 00:11:09,760
that it actually takes us longer to

351
00:11:09,760 --> 00:11:12,079
generate the random strings and feed

352
00:11:12,079 --> 00:11:13,600
them to the gpus

353
00:11:13,600 --> 00:11:16,320
than it does for the gpus to process

354
00:11:16,320 --> 00:11:17,760
those random strings

355
00:11:17,760 --> 00:11:19,440
especially because you can't just feed

356
00:11:19,440 --> 00:11:21,120
it a single random string and expect it

357
00:11:21,120 --> 00:11:21,440
to

358
00:11:21,440 --> 00:11:23,120
finish things really quickly you have to

359
00:11:23,120 --> 00:11:26,240
feed it entire blocks of random strings

360
00:11:26,240 --> 00:11:29,120
super super fast and so unlike on the

361
00:11:29,120 --> 00:11:31,200
cpu implementation i don't have

362
00:11:31,200 --> 00:11:34,000
a separate random number generator and a

363
00:11:34,000 --> 00:11:34,800
separate

364
00:11:34,800 --> 00:11:38,399
um gpu checker instead what i do

365
00:11:38,399 --> 00:11:40,959
is i have a single cuda kernel that will

366
00:11:40,959 --> 00:11:42,560
take a random seed

367
00:11:42,560 --> 00:11:45,440
use that random seed to generate random

368
00:11:45,440 --> 00:11:46,399
strings

369
00:11:46,399 --> 00:11:49,120
and at the same time check whether or

370
00:11:49,120 --> 00:11:50,880
not those random strings actually match

371
00:11:50,880 --> 00:11:51,920
our condition

372
00:11:51,920 --> 00:11:54,959
that way we save out on two bottlenecks

373
00:11:54,959 --> 00:11:57,440
first of all generating on cpu is slow

374
00:11:57,440 --> 00:11:59,120
compared to what the gpu needs to feed

375
00:11:59,120 --> 00:12:00,720
it to full efficiency

376
00:12:00,720 --> 00:12:03,040
second we don't need to generate all of

377
00:12:03,040 --> 00:12:04,639
those strings on cpu

378
00:12:04,639 --> 00:12:07,120
and then copy that entire block of

379
00:12:07,120 --> 00:12:08,160
memory

380
00:12:08,160 --> 00:12:11,200
over to gpu over pcie instead what we

381
00:12:11,200 --> 00:12:12,079
can do

382
00:12:12,079 --> 00:12:14,959
is we can simply generate and use it on

383
00:12:14,959 --> 00:12:15,839
the gpu

384
00:12:15,839 --> 00:12:17,279
that way we don't even need to have a

385
00:12:17,279 --> 00:12:18,880
block of memory for this stuff we can

386
00:12:18,880 --> 00:12:21,279
just keep it entirely in registers so

387
00:12:21,279 --> 00:12:24,079
it's really fun stuff that we can do

388
00:12:24,079 --> 00:12:26,639
if we're able to do it directly within

389
00:12:26,639 --> 00:12:27,600
the single kernel

390
00:12:27,600 --> 00:12:29,519
that's why i've merged it all into a

391
00:12:29,519 --> 00:12:30,959
single function but now

392
00:12:30,959 --> 00:12:32,320
i know what you're thinking how exactly

393
00:12:32,320 --> 00:12:34,000
does this work so let's get into that

394
00:12:34,000 --> 00:12:35,920
now first of all of course after my

395
00:12:35,920 --> 00:12:37,360
traditional imports

396
00:12:37,360 --> 00:12:39,600
i've got a couple of definitions over

397
00:12:39,600 --> 00:12:41,120
here and i want to quickly go through

398
00:12:41,120 --> 00:12:42,160
those definitions

399
00:12:42,160 --> 00:12:44,800
so i start off by defining the text so

400
00:12:44,800 --> 00:12:46,720
this is the prefix that we want to feed

401
00:12:46,720 --> 00:12:47,440
into

402
00:12:47,440 --> 00:12:50,880
the actual program so that we can find

403
00:12:50,880 --> 00:12:52,800
some text that when appended to this

404
00:12:52,800 --> 00:12:54,560
text the result

405
00:12:54,560 --> 00:12:56,959
gives us a shot 256 hash that starts

406
00:12:56,959 --> 00:12:58,639
with a certain number of zeros

407
00:12:58,639 --> 00:13:00,720
i'm also just having to define we're

408
00:13:00,720 --> 00:13:02,240
working with c so

409
00:13:02,240 --> 00:13:04,079
i have to define things like how long

410
00:13:04,079 --> 00:13:06,560
the text is i've got to find how many

411
00:13:06,560 --> 00:13:09,120
and this is a sort of gpu part these

412
00:13:09,120 --> 00:13:10,639
three variables over here

413
00:13:10,639 --> 00:13:13,440
i've got to define how many threads i

414
00:13:13,440 --> 00:13:15,760
want the gpu to execute

415
00:13:15,760 --> 00:13:19,040
i want to define how many blocks

416
00:13:19,040 --> 00:13:21,440
of these threads the gpu is going to

417
00:13:21,440 --> 00:13:22,399
execute

418
00:13:22,399 --> 00:13:24,079
and i wanted to find how many gpus i

419
00:13:24,079 --> 00:13:25,519
want to use in total

420
00:13:25,519 --> 00:13:27,519
so the way this works and this is a

421
00:13:27,519 --> 00:13:30,079
little interesting the way cuda

422
00:13:30,079 --> 00:13:33,200
wraps its um wraps its compute

423
00:13:33,200 --> 00:13:36,079
with cuda you don't just have n number

424
00:13:36,079 --> 00:13:37,600
of threads

425
00:13:37,600 --> 00:13:40,880
you have n number of blocks each block

426
00:13:40,880 --> 00:13:44,000
containing n number of threads and so

427
00:13:44,000 --> 00:13:45,360
it's it's interesting the way that

428
00:13:45,360 --> 00:13:46,800
happens in different

429
00:13:46,800 --> 00:13:48,959
use cases you want to have different

430
00:13:48,959 --> 00:13:50,000
arrangements of

431
00:13:50,000 --> 00:13:53,440
blocks to threads you can specify that

432
00:13:53,440 --> 00:13:55,360
there's of course limitations and it

433
00:13:55,360 --> 00:13:56,720
really depends on things like the warp

434
00:13:56,720 --> 00:13:58,079
size of your gpu

435
00:13:58,079 --> 00:14:01,120
but in this case i found 1500 256 to be

436
00:14:01,120 --> 00:14:02,000
a good combination

437
00:14:02,000 --> 00:14:04,320
for this gpu in this use case and so you

438
00:14:04,320 --> 00:14:05,920
want to really specify this

439
00:14:05,920 --> 00:14:08,480
to what it is that you are doing

440
00:14:08,480 --> 00:14:10,320
although this is a pretty good

441
00:14:10,320 --> 00:14:13,360
standard set is what i would say now of

442
00:14:13,360 --> 00:14:14,800
course the way this code works and this

443
00:14:14,800 --> 00:14:16,000
is the fun part

444
00:14:16,000 --> 00:14:18,240
is that the gpus that this

445
00:14:18,240 --> 00:14:19,519
implementation that i've created

446
00:14:19,519 --> 00:14:21,680
actually supports multiple gpus and so

447
00:14:21,680 --> 00:14:22,639
what that means is

448
00:14:22,639 --> 00:14:23,920
you could have a machine with 10

449
00:14:23,920 --> 00:14:25,519
different gpus on it and you could just

450
00:14:25,519 --> 00:14:26,000
say

451
00:14:26,000 --> 00:14:27,760
i want to run on 10 gpus and the rest of

452
00:14:27,760 --> 00:14:30,000
the program will automatically fit

453
00:14:30,000 --> 00:14:32,880
uh to run on 10 gpus or even just one

454
00:14:32,880 --> 00:14:33,760
but this case

455
00:14:33,760 --> 00:14:36,320
i've got four gpus now i also want to

456
00:14:36,320 --> 00:14:38,160
specify the difficulty

457
00:14:38,160 --> 00:14:39,680
so what is the difficulty you may ask

458
00:14:39,680 --> 00:14:41,680
well remember what we want to do is we

459
00:14:41,680 --> 00:14:43,600
want the output of the challenge

460
00:14:43,600 --> 00:14:46,320
to say a certain number of zeros that a

461
00:14:46,320 --> 00:14:48,160
certain shot 256 hash

462
00:14:48,160 --> 00:14:51,440
should start with in this case we want

463
00:14:51,440 --> 00:14:54,160
the algorithm to output a sha-256 hash

464
00:14:54,160 --> 00:14:57,120
which starts with four consecutive bytes

465
00:14:57,120 --> 00:14:58,639
worth of zeros

466
00:14:58,639 --> 00:15:01,680
that's a lot of zeros so that's

467
00:15:01,680 --> 00:15:04,000
that's 32 zeros that we're asking it to

468
00:15:04,000 --> 00:15:05,680
do in fact if you see a little bit later

469
00:15:05,680 --> 00:15:07,360
in the code we actually bump that up

470
00:15:07,360 --> 00:15:09,120
even further a little bit by a few more

471
00:15:09,120 --> 00:15:09,760
bits

472
00:15:09,760 --> 00:15:11,680
so this is a really really intense

473
00:15:11,680 --> 00:15:13,440
challenge and i can't wait to see what

474
00:15:13,440 --> 00:15:15,040
the performance numbers are like

475
00:15:15,040 --> 00:15:16,959
from there though i also do go ahead and

476
00:15:16,959 --> 00:15:18,639
define the random length so this is the

477
00:15:18,639 --> 00:15:19,199
length

478
00:15:19,199 --> 00:15:21,360
the maximum the actual length of the

479
00:15:21,360 --> 00:15:22,480
number of bytes

480
00:15:22,480 --> 00:15:24,560
that we want to append to the text to

481
00:15:24,560 --> 00:15:26,240
come up with the hash

482
00:15:26,240 --> 00:15:27,760
now from there i just have a pretty

483
00:15:27,760 --> 00:15:29,199
simple function called chara not

484
00:15:29,199 --> 00:15:29,759
function

485
00:15:29,759 --> 00:15:32,480
the constant called character set this

486
00:15:32,480 --> 00:15:33,440
is the set

487
00:15:33,440 --> 00:15:36,880
from which we can actually choose a

488
00:15:36,880 --> 00:15:40,079
random letter or a random character to

489
00:15:40,079 --> 00:15:40,880
insert

490
00:15:40,880 --> 00:15:44,480
uh into our into our solution and so

491
00:15:44,480 --> 00:15:46,320
we can of course add more characters to

492
00:15:46,320 --> 00:15:47,920
this if we want we can remove it doesn't

493
00:15:47,920 --> 00:15:48,959
really matter

494
00:15:48,959 --> 00:15:50,959
in this case just to keep it readable i

495
00:15:50,959 --> 00:15:52,560
decided to have a pretty standard set of

496
00:15:52,560 --> 00:15:53,759
characters

497
00:15:53,759 --> 00:15:55,680
and from there i've got a function and

498
00:15:55,680 --> 00:15:56,959
this is where the fun starts this is a

499
00:15:56,959 --> 00:15:58,639
device function called device

500
00:15:58,639 --> 00:16:00,880
random gen device random gen what it

501
00:16:00,880 --> 00:16:02,880
does is a suit a random generation

502
00:16:02,880 --> 00:16:03,440
function

503
00:16:03,440 --> 00:16:05,360
that takes an unsigned long to an

504
00:16:05,360 --> 00:16:07,600
unsigned 64-bit integer

505
00:16:07,600 --> 00:16:10,000
and it does a bunch of bit operations

506
00:16:10,000 --> 00:16:11,839
bit shifts things like that

507
00:16:11,839 --> 00:16:14,399
and it's going to try and essentially

508
00:16:14,399 --> 00:16:15,920
create a random number now

509
00:16:15,920 --> 00:16:18,240
you can't really create a random number

510
00:16:18,240 --> 00:16:20,079
with computers as they are today that's

511
00:16:20,079 --> 00:16:21,360
not how they work

512
00:16:21,360 --> 00:16:24,079
that's impossible but what you can do is

513
00:16:24,079 --> 00:16:24,720
you can

514
00:16:24,720 --> 00:16:27,440
make a function such that the input even

515
00:16:27,440 --> 00:16:29,040
if it changes very very slightly the

516
00:16:29,040 --> 00:16:31,199
output changes a lot

517
00:16:31,199 --> 00:16:33,519
and that's how random number generators

518
00:16:33,519 --> 00:16:35,120
work in computers today

519
00:16:35,120 --> 00:16:37,759
and this is an implementation of a super

520
00:16:37,759 --> 00:16:38,959
rudimentary

521
00:16:38,959 --> 00:16:41,920
random number generation function now if

522
00:16:41,920 --> 00:16:43,360
we wanted things like

523
00:16:43,360 --> 00:16:44,800
being able to be cryptographically

524
00:16:44,800 --> 00:16:46,959
secure we wouldn't be using this ha

525
00:16:46,959 --> 00:16:49,519
this random generation algorithm but if

526
00:16:49,519 --> 00:16:51,279
you think about it we don't need to be

527
00:16:51,279 --> 00:16:52,399
cryptographically secure

528
00:16:52,399 --> 00:16:53,839
we just want a random number function

529
00:16:53,839 --> 00:16:55,680
that's relatively uniform

530
00:16:55,680 --> 00:16:57,120
with the input that we give it or the

531
00:16:57,120 --> 00:16:59,040
bounds that we give it this is

532
00:16:59,040 --> 00:17:01,199
quite uniform and so we don't need to go

533
00:17:01,199 --> 00:17:02,880
more advanced in fact the simpler this

534
00:17:02,880 --> 00:17:03,680
function is

535
00:17:03,680 --> 00:17:06,640
the more cpu call or gpu clock cycles we

536
00:17:06,640 --> 00:17:07,679
can shave off

537
00:17:07,679 --> 00:17:10,720
that adds up to millions of cycles

538
00:17:10,720 --> 00:17:12,480
you know many seconds of compute which

539
00:17:12,480 --> 00:17:13,760
are really valuable here

540
00:17:13,760 --> 00:17:15,679
so just a super simple random number

541
00:17:15,679 --> 00:17:17,600
generation function

542
00:17:17,600 --> 00:17:19,439
now from there i'm going to go ahead and

543
00:17:19,439 --> 00:17:21,120
skip this function for now

544
00:17:21,120 --> 00:17:22,480
i'll tell you what it does and we'll

545
00:17:22,480 --> 00:17:24,720
come back to it basically this is the

546
00:17:24,720 --> 00:17:26,400
this is the cuda kernel

547
00:17:26,400 --> 00:17:28,799
the cuda kernel that is responsible for

548
00:17:28,799 --> 00:17:29,440
taking

549
00:17:29,440 --> 00:17:32,799
the input text it's taking a pointer to

550
00:17:32,799 --> 00:17:34,799
where to store a solution

551
00:17:34,799 --> 00:17:37,440
if it finds a solution it's taking a

552
00:17:37,440 --> 00:17:39,520
pointer to a variable

553
00:17:39,520 --> 00:17:42,240
where it will store a boolean value of

554
00:17:42,240 --> 00:17:43,440
whether or not the

555
00:17:43,440 --> 00:17:46,720
kernel has found a solution as well as

556
00:17:46,720 --> 00:17:49,919
the random seed now really quickly uh

557
00:17:49,919 --> 00:17:50,640
i'm going to

558
00:17:50,640 --> 00:17:52,640
say whatever i just said how does that

559
00:17:52,640 --> 00:17:53,760
sort of relate to the function

560
00:17:53,760 --> 00:17:55,200
parameters let's take a look

561
00:17:55,200 --> 00:17:57,120
so as you can see this over here is the

562
00:17:57,120 --> 00:17:59,360
string or the byte pointer

563
00:17:59,360 --> 00:18:01,200
to the prefix that we want to that we

564
00:18:01,200 --> 00:18:02,559
want to pen to

565
00:18:02,559 --> 00:18:04,400
there's also the byte pointer to the

566
00:18:04,400 --> 00:18:06,080
solution which is by default a null

567
00:18:06,080 --> 00:18:07,600
pointer however

568
00:18:07,600 --> 00:18:10,320
uh not null pointer per se but you know

569
00:18:10,320 --> 00:18:12,080
it's not initialized memory

570
00:18:12,080 --> 00:18:14,640
um and uh what's what's gonna happen is

571
00:18:14,640 --> 00:18:16,640
if this cuda kernel finds a solution to

572
00:18:16,640 --> 00:18:18,320
the problem it'll put the solution

573
00:18:18,320 --> 00:18:20,880
into this pointer uh or where this where

574
00:18:20,880 --> 00:18:22,799
this pointer points

575
00:18:22,799 --> 00:18:24,880
as well as just an integer or a boolean

576
00:18:24,880 --> 00:18:28,320
value uh by default this is negative one

577
00:18:28,320 --> 00:18:31,360
and what we want to do is set this to

578
00:18:31,360 --> 00:18:35,120
one if the cuda kernel finds a solution

579
00:18:35,120 --> 00:18:37,280
so that way the cpu knows if we actually

580
00:18:37,280 --> 00:18:38,400
have a solution

581
00:18:38,400 --> 00:18:40,799
and of course as i mentioned the basic

582
00:18:40,799 --> 00:18:42,320
random number generator seat

583
00:18:42,320 --> 00:18:44,080
um now we'll come back to this function

584
00:18:44,080 --> 00:18:46,080
in just a moment but first i want to go

585
00:18:46,080 --> 00:18:46,640
ahead

586
00:18:46,640 --> 00:18:48,400
uh as i mentioned we want to have super

587
00:18:48,400 --> 00:18:50,000
simple random number generation so i

588
00:18:50,000 --> 00:18:51,280
also have a version of that same

589
00:18:51,280 --> 00:18:53,280
function for the host for the cpu

590
00:18:53,280 --> 00:18:55,360
that will be compiled to cpu assembly

591
00:18:55,360 --> 00:18:57,039
not gpu

592
00:18:57,039 --> 00:19:00,160
i also just have a little pre-shot 256

593
00:19:00,160 --> 00:19:01,600
function this is mostly a legacy

594
00:19:01,600 --> 00:19:02,400
carryover

595
00:19:02,400 --> 00:19:03,840
from the previous codebase that i'm

596
00:19:03,840 --> 00:19:05,760
going to link in the link to in the code

597
00:19:05,760 --> 00:19:06,400
bait

598
00:19:06,400 --> 00:19:08,960
link to in the description there's

599
00:19:08,960 --> 00:19:10,880
definitely a much better way to do this

600
00:19:10,880 --> 00:19:12,080
you could literally just put

601
00:19:12,080 --> 00:19:13,919
underscoring the sort constant

602
00:19:13,919 --> 00:19:16,320
um as a prefix for the variable but

603
00:19:16,320 --> 00:19:18,400
anyhow this is a legacy carryover

604
00:19:18,400 --> 00:19:21,440
which can be removed in a later commit

605
00:19:21,440 --> 00:19:23,919
from there i also have a long long

606
00:19:23,919 --> 00:19:25,520
called time milliseconds

607
00:19:25,520 --> 00:19:28,160
this is going to return the current time

608
00:19:28,160 --> 00:19:29,600
in milliseconds

609
00:19:29,600 --> 00:19:30,960
that way i can actually go ahead and

610
00:19:30,960 --> 00:19:32,559
time things like execution and figure

611
00:19:32,559 --> 00:19:33,760
out how many hashes

612
00:19:33,760 --> 00:19:37,440
we're processing per second from there

613
00:19:37,440 --> 00:19:41,440
this is where the the sort of cpu gpu

614
00:19:41,440 --> 00:19:43,840
interconnect comes in we start off by

615
00:19:43,840 --> 00:19:45,520
defining a structure called

616
00:19:45,520 --> 00:19:48,720
handler input what is handler input well

617
00:19:48,720 --> 00:19:49,600
the way this

618
00:19:49,600 --> 00:19:51,440
implementation works is of course

619
00:19:51,440 --> 00:19:53,120
there's the main thread and that's

620
00:19:53,120 --> 00:19:53,600
what's

621
00:19:53,600 --> 00:19:55,120
that's the thread that's that the

622
00:19:55,120 --> 00:19:56,880
program is launched from

623
00:19:56,880 --> 00:19:59,679
the main thread actually spawns a bunch

624
00:19:59,679 --> 00:20:00,960
of different threads

625
00:20:00,960 --> 00:20:03,840
specifically however it'll spawn n

626
00:20:03,840 --> 00:20:04,880
number of threads

627
00:20:04,880 --> 00:20:06,880
where n is the number of gpus that you

628
00:20:06,880 --> 00:20:07,919
want to execute on

629
00:20:07,919 --> 00:20:09,360
so if you only have a single gpu it'll

630
00:20:09,360 --> 00:20:11,280
spawn a single thread if you've got 10

631
00:20:11,280 --> 00:20:14,240
it'll spawn 10 threads now each thread

632
00:20:14,240 --> 00:20:15,440
is responsible for

633
00:20:15,440 --> 00:20:17,919
handling the input output for a single

634
00:20:17,919 --> 00:20:19,600
gpu

635
00:20:19,600 --> 00:20:22,559
and of course as the handler it needs to

636
00:20:22,559 --> 00:20:24,400
have some sort of input to tell it what

637
00:20:24,400 --> 00:20:25,120
to do

638
00:20:25,120 --> 00:20:26,960
so this is the handler input structure

639
00:20:26,960 --> 00:20:29,200
it tells each handler thread

640
00:20:29,200 --> 00:20:31,360
information about what it needs to do

641
00:20:31,360 --> 00:20:32,880
and how it needs to do it

642
00:20:32,880 --> 00:20:34,240
in this case the only things that it

643
00:20:34,240 --> 00:20:36,400
needs to know would be first of all

644
00:20:36,400 --> 00:20:38,720
the device so what device exactly are we

645
00:20:38,720 --> 00:20:40,240
using are we using the first gpu the

646
00:20:40,240 --> 00:20:40,720
second

647
00:20:40,720 --> 00:20:42,480
fourth the tenth what are we using for

648
00:20:42,480 --> 00:20:43,840
this specific thread

649
00:20:43,840 --> 00:20:46,880
but also within the handler input

650
00:20:46,880 --> 00:20:49,440
i want to store an unsigned long called

651
00:20:49,440 --> 00:20:50,880
hash is processed

652
00:20:50,880 --> 00:20:53,120
that way whenever the whenever the

653
00:20:53,120 --> 00:20:55,280
worker actually processes say

654
00:20:55,280 --> 00:20:57,679
n number of hashes i can go ahead and

655
00:20:57,679 --> 00:20:58,559
store that

656
00:20:58,559 --> 00:21:00,720
here and say i've processed these many

657
00:21:00,720 --> 00:21:02,240
more hashes and the main

658
00:21:02,240 --> 00:21:04,159
thread can continuously look at that

659
00:21:04,159 --> 00:21:05,840
pointer and always be like all right

660
00:21:05,840 --> 00:21:07,200
you're incrementing the number of hashes

661
00:21:07,200 --> 00:21:08,000
you process

662
00:21:08,000 --> 00:21:09,679
you don't need to do this in a real life

663
00:21:09,679 --> 00:21:11,440
scenario you probably wouldn't

664
00:21:11,440 --> 00:21:13,120
but this is for benchmarking this is so

665
00:21:13,120 --> 00:21:15,039
that we know how many hashes we're

666
00:21:15,039 --> 00:21:17,200
processing per second

667
00:21:17,200 --> 00:21:18,960
and you'll be pretty surprised when i

668
00:21:18,960 --> 00:21:20,559
actually run this code just

669
00:21:20,559 --> 00:21:23,760
how fast it is but anyhow from there i

670
00:21:23,760 --> 00:21:26,159
also just have two more global variables

671
00:21:26,159 --> 00:21:28,720
one is the solution lock and so this is

672
00:21:28,720 --> 00:21:29,760
a mutex

673
00:21:29,760 --> 00:21:31,600
that makes it so that the main thread

674
00:21:31,600 --> 00:21:34,159
knows when a worker has found a solution

675
00:21:34,159 --> 00:21:37,280
as well as a global pointer uh

676
00:21:37,280 --> 00:21:40,400
to uh to solution um now

677
00:21:40,400 --> 00:21:42,159
basically this is this is the chunk of

678
00:21:42,159 --> 00:21:44,240
cpu memory that will actually contain

679
00:21:44,240 --> 00:21:45,280
the solution

680
00:21:45,280 --> 00:21:48,640
if we find one hopefully we do now

681
00:21:48,640 --> 00:21:50,880
this function over here this absolute

682
00:21:50,880 --> 00:21:52,159
unit um

683
00:21:52,159 --> 00:21:54,000
is going to be responsible for actually

684
00:21:54,000 --> 00:21:55,760
launching and and

685
00:21:55,760 --> 00:21:57,520
and sort of maintaining the gpu handler

686
00:21:57,520 --> 00:22:00,400
thread it takes a void pointer so a raw

687
00:22:00,400 --> 00:22:01,600
pointer

688
00:22:01,600 --> 00:22:04,000
and that void pointer is then casted to

689
00:22:04,000 --> 00:22:06,240
a handler input pointer

690
00:22:06,240 --> 00:22:08,640
and so that that enables us to know what

691
00:22:08,640 --> 00:22:09,440
the input is

692
00:22:09,440 --> 00:22:11,600
now the first thing we got to do right

693
00:22:11,600 --> 00:22:14,000
off the bat before we even begin

694
00:22:14,000 --> 00:22:16,640
is take the device that that handler is

695
00:22:16,640 --> 00:22:18,400
responsible for handling

696
00:22:18,400 --> 00:22:20,799
and tell cuda that this thread intends

697
00:22:20,799 --> 00:22:22,240
to work with that device

698
00:22:22,240 --> 00:22:24,799
so that we can get a context that tells

699
00:22:24,799 --> 00:22:26,320
us that we're only working with that

700
00:22:26,320 --> 00:22:27,280
device

701
00:22:27,280 --> 00:22:28,960
so the first thing we've got to do set

702
00:22:28,960 --> 00:22:31,120
device that's the most important part

703
00:22:31,120 --> 00:22:33,679
then the rest follows first of all we're

704
00:22:33,679 --> 00:22:35,440
doing is of course that legacy carryover

705
00:22:35,440 --> 00:22:37,919
i was talking about pre-shot 256

706
00:22:37,919 --> 00:22:40,559
set up the gpu memory a little bit from

707
00:22:40,559 --> 00:22:42,240
there what i do is essentially just

708
00:22:42,240 --> 00:22:46,240
allocate blocks of cpu and corresponding

709
00:22:46,240 --> 00:22:48,559
gpu memory and sync them so that

710
00:22:48,559 --> 00:22:51,200
we know what we're doing now cuda has

711
00:22:51,200 --> 00:22:53,200
some fancy new features that enable

712
00:22:53,200 --> 00:22:54,720
things like for example being able to

713
00:22:54,720 --> 00:22:56,480
access gpu memory from the cpu

714
00:22:56,480 --> 00:22:57,760
implicitly

715
00:22:57,760 --> 00:23:00,159
but the thing is that introduces very

716
00:23:00,159 --> 00:23:01,120
very little

717
00:23:01,120 --> 00:23:03,440
overhead but it's overhead nonetheless

718
00:23:03,440 --> 00:23:05,120
and the entire point of this application

719
00:23:05,120 --> 00:23:06,000
is to be as

720
00:23:06,000 --> 00:23:08,880
blazingly fast as possible so i'm not

721
00:23:08,880 --> 00:23:10,559
using those fancy new

722
00:23:10,559 --> 00:23:12,240
convenient techniques we're still going

723
00:23:12,240 --> 00:23:13,919
the old-fashioned way

724
00:23:13,919 --> 00:23:16,799
and that old-fashioned way uh is i go

725
00:23:16,799 --> 00:23:18,080
ahead and create

726
00:23:18,080 --> 00:23:20,159
uh first of all the cpu prefix right so

727
00:23:20,159 --> 00:23:22,240
i go ahead and um

728
00:23:22,240 --> 00:23:24,720
get the text uh that that we're looking

729
00:23:24,720 --> 00:23:25,600
for

730
00:23:25,600 --> 00:23:27,679
put that into a pointer and i go ahead

731
00:23:27,679 --> 00:23:28,880
and also allocate

732
00:23:28,880 --> 00:23:31,120
uh memory for that space for that on the

733
00:23:31,120 --> 00:23:32,640
gpu

734
00:23:32,640 --> 00:23:34,320
so i get a byte pointer but this isn't

735
00:23:34,320 --> 00:23:36,400
like a traditional c pointer this is a

736
00:23:36,400 --> 00:23:37,679
cuda malloc

737
00:23:37,679 --> 00:23:40,960
c pointer this is owned by the gpu

738
00:23:40,960 --> 00:23:43,919
um and so so that's something to keep

739
00:23:43,919 --> 00:23:44,159
and

740
00:23:44,159 --> 00:23:46,400
keep in mind then what i do is a simple

741
00:23:46,400 --> 00:23:48,720
cuda memory copy so i copy the cpu

742
00:23:48,720 --> 00:23:50,080
prefix over

743
00:23:50,080 --> 00:23:52,880
to the device and this is a host to

744
00:23:52,880 --> 00:23:54,960
device transfer host being cpu

745
00:23:54,960 --> 00:23:57,760
device being gpu then i go ahead and

746
00:23:57,760 --> 00:23:58,400
allocate

747
00:23:58,400 --> 00:24:00,320
memory for the actual solution if and

748
00:24:00,320 --> 00:24:01,679
when we find it

749
00:24:01,679 --> 00:24:03,279
again there's no guarantee we will but

750
00:24:03,279 --> 00:24:04,720
if we do we want to have memory to

751
00:24:04,720 --> 00:24:05,679
actually store it

752
00:24:05,679 --> 00:24:07,919
i then go ahead and and allocate the

753
00:24:07,919 --> 00:24:09,279
same memory for the device

754
00:24:09,279 --> 00:24:11,520
no syncing is required here uh because

755
00:24:11,520 --> 00:24:13,200
that comes later

756
00:24:13,200 --> 00:24:14,960
then finally i also just allocate the

757
00:24:14,960 --> 00:24:17,840
memory for the block contains solution

758
00:24:17,840 --> 00:24:20,720
variable which i mean even an integer

759
00:24:20,720 --> 00:24:22,640
needs to be allocated with cuda you

760
00:24:22,640 --> 00:24:24,000
couldn't just say

761
00:24:24,000 --> 00:24:25,679
you know int block contains solution

762
00:24:25,679 --> 00:24:26,880
equals negative one and then pass a

763
00:24:26,880 --> 00:24:27,679
pointer because

764
00:24:27,679 --> 00:24:29,600
you want to specifically do a cuda

765
00:24:29,600 --> 00:24:31,200
malloc so it's

766
00:24:31,200 --> 00:24:32,880
pretty interesting there but then again

767
00:24:32,880 --> 00:24:35,200
i just copy the device version to the

768
00:24:35,200 --> 00:24:36,000
cuda version

769
00:24:36,000 --> 00:24:37,279
because the device version is set to

770
00:24:37,279 --> 00:24:39,279
negative one and we also want the cuda

771
00:24:39,279 --> 00:24:39,760
version

772
00:24:39,760 --> 00:24:43,120
to be set to negative one now after that

773
00:24:43,120 --> 00:24:44,799
i just go ahead and get a random number

774
00:24:44,799 --> 00:24:46,880
generator seed which by default is equal

775
00:24:46,880 --> 00:24:47,440
to

776
00:24:47,440 --> 00:24:50,320
uh the time in milliseconds and then

777
00:24:50,320 --> 00:24:51,120
after that

778
00:24:51,120 --> 00:24:53,279
we go ahead and start handling the gpu

779
00:24:53,279 --> 00:24:54,640
because we've got all of our

780
00:24:54,640 --> 00:24:58,480
basic stuff figured out

781
00:24:58,480 --> 00:25:00,720
now the way this is going to work is we

782
00:25:00,720 --> 00:25:03,279
start off by actually taking uh the host

783
00:25:03,279 --> 00:25:04,880
random number generator function

784
00:25:04,880 --> 00:25:07,600
and feeding the time in milliseconds to

785
00:25:07,600 --> 00:25:08,559
that function

786
00:25:08,559 --> 00:25:11,039
so we can modify it so we can mutate it

787
00:25:11,039 --> 00:25:13,120
across every iteration because of course

788
00:25:13,120 --> 00:25:15,120
every iteration when we call the gpu we

789
00:25:15,120 --> 00:25:16,320
don't want to be using the same random

790
00:25:16,320 --> 00:25:16,960
seed we would be

791
00:25:16,960 --> 00:25:19,679
doing literally nothing and so we go

792
00:25:19,679 --> 00:25:21,200
ahead and pass up the random seed

793
00:25:21,200 --> 00:25:23,360
make it modify and then what i go ahead

794
00:25:23,360 --> 00:25:24,960
and do is take the number of threads

795
00:25:24,960 --> 00:25:26,960
per block take the number of blocks

796
00:25:26,960 --> 00:25:28,000
multiply to figure

797
00:25:28,000 --> 00:25:30,159
out how many hashes the gpu was about to

798
00:25:30,159 --> 00:25:31,120
process

799
00:25:31,120 --> 00:25:33,679
i then go ahead and add those to the

800
00:25:33,679 --> 00:25:36,080
total number of hashes processed

801
00:25:36,080 --> 00:25:38,320
once that's done now the main thread

802
00:25:38,320 --> 00:25:40,240
knows that we're processing hashes right

803
00:25:40,240 --> 00:25:42,240
not exactly important but it's good for

804
00:25:42,240 --> 00:25:43,360
benchmarking

805
00:25:43,360 --> 00:25:44,559
then i go ahead and do something called

806
00:25:44,559 --> 00:25:46,960
a cuda kernel invocation the kuda kernel

807
00:25:46,960 --> 00:25:47,760
invocation

808
00:25:47,760 --> 00:25:49,840
is gonna look like a function call but

809
00:25:49,840 --> 00:25:51,520
has this weird

810
00:25:51,520 --> 00:25:53,520
thing in the middle and this weird thing

811
00:25:53,520 --> 00:25:55,440
is telling cuda how many threads and how

812
00:25:55,440 --> 00:25:56,960
many blocks we want to execute on so

813
00:25:56,960 --> 00:25:58,320
it's telling it the topology of the

814
00:25:58,320 --> 00:26:00,080
execution

815
00:26:00,080 --> 00:26:01,679
once we've done that we want to pass it

816
00:26:01,679 --> 00:26:03,360
the device prefix the device solution

817
00:26:03,360 --> 00:26:04,799
the device whether or not contains a

818
00:26:04,799 --> 00:26:06,080
solution

819
00:26:06,080 --> 00:26:08,480
and the random number generator seed so

820
00:26:08,480 --> 00:26:09,120
i know that's

821
00:26:09,120 --> 00:26:10,720
a mouthful but i've already described

822
00:26:10,720 --> 00:26:12,640
these parameters uh the four of these

823
00:26:12,640 --> 00:26:14,559
parameters are responsible for

824
00:26:14,559 --> 00:26:16,320
you know telling the gpu what to do and

825
00:26:16,320 --> 00:26:17,600
getting a result

826
00:26:17,600 --> 00:26:20,080
once the gpu actually has a result to

827
00:26:20,080 --> 00:26:21,520
give us

828
00:26:21,520 --> 00:26:22,720
then i go ahead and run a function

829
00:26:22,720 --> 00:26:24,559
called cuda device synchronize

830
00:26:24,559 --> 00:26:27,679
so this is kind of like p thread join

831
00:26:27,679 --> 00:26:30,960
for for cpu but for gpu instead except

832
00:26:30,960 --> 00:26:32,400
this is going to wait for any

833
00:26:32,400 --> 00:26:34,000
non-blocking operations it's going to

834
00:26:34,000 --> 00:26:35,600
block until they're all done

835
00:26:35,600 --> 00:26:37,760
this includes cuda kernels this includes

836
00:26:37,760 --> 00:26:39,919
cuda memory copies this includes

837
00:26:39,919 --> 00:26:42,080
anything that's non-blocking this will

838
00:26:42,080 --> 00:26:43,679
block it for you

839
00:26:43,679 --> 00:26:45,360
and so this is there so we can actually

840
00:26:45,360 --> 00:26:46,880
wait for the kernel to finish

841
00:26:46,880 --> 00:26:50,000
executing once that's done then i

842
00:26:50,000 --> 00:26:51,200
execute only a

843
00:26:51,200 --> 00:26:53,919
single and a very small memory copy

844
00:26:53,919 --> 00:26:54,880
every iteration

845
00:26:54,880 --> 00:26:56,400
only a single memory copy so we're

846
00:26:56,400 --> 00:26:59,279
trying to reduce bottlenecks here

847
00:26:59,279 --> 00:27:01,120
and that memory copy is going to copy

848
00:27:01,120 --> 00:27:02,880
the boolean of whether or not a block

849
00:27:02,880 --> 00:27:04,880
contains a solution

850
00:27:04,880 --> 00:27:08,159
from gpu memory to cpu memory

851
00:27:08,159 --> 00:27:10,960
uh once that's done then we're gonna

852
00:27:10,960 --> 00:27:12,799
check if it's equal to one so did the

853
00:27:12,799 --> 00:27:15,200
gpu find a solution in this iteration

854
00:27:15,200 --> 00:27:17,840
if it did then we're gonna do a bit more

855
00:27:17,840 --> 00:27:19,760
of an expensive memory copy

856
00:27:19,760 --> 00:27:22,080
which will copy the actual solution over

857
00:27:22,080 --> 00:27:24,159
from gpu memory to cpu memory

858
00:27:24,159 --> 00:27:26,559
we're going to assign that solution to

859
00:27:26,559 --> 00:27:27,840
the global variable

860
00:27:27,840 --> 00:27:29,360
and then we're going to unlock the

861
00:27:29,360 --> 00:27:31,200
solution lock

862
00:27:31,200 --> 00:27:32,799
so what's going to happen is in the

863
00:27:32,799 --> 00:27:35,200
beginning the main thread is going to

864
00:27:35,200 --> 00:27:38,000
lock the solution lock it's going to

865
00:27:38,000 --> 00:27:39,360
launch the threads

866
00:27:39,360 --> 00:27:41,600
and it's going to attempt to lock it

867
00:27:41,600 --> 00:27:42,799
again

868
00:27:42,799 --> 00:27:44,960
now when it comes to lock the solution

869
00:27:44,960 --> 00:27:45,919
lock for a second

870
00:27:45,919 --> 00:27:48,559
time it's going to block the main thread

871
00:27:48,559 --> 00:27:49,600
it's going to block

872
00:27:49,600 --> 00:27:52,640
because well we don't have a solution

873
00:27:52,640 --> 00:27:55,919
and so what's going to happen is when a

874
00:27:55,919 --> 00:27:57,039
handler thread actually

875
00:27:57,039 --> 00:28:00,240
finds a solution it's going to unlock

876
00:28:00,240 --> 00:28:01,520
the solution lock

877
00:28:01,520 --> 00:28:03,120
which means the main thread cannot lock

878
00:28:03,120 --> 00:28:04,799
it again and it's done blocking it can

879
00:28:04,799 --> 00:28:06,080
continue connecting it can actually

880
00:28:06,080 --> 00:28:07,279
print out the solution

881
00:28:07,279 --> 00:28:09,120
so it's a it's an interesting way i

882
00:28:09,120 --> 00:28:10,799
wanted to use semaphores

883
00:28:10,799 --> 00:28:12,799
um but the problem was that for some

884
00:28:12,799 --> 00:28:15,279
reason on mac samplers wouldn't block

885
00:28:15,279 --> 00:28:18,240
which almost seems like a bug but

886
00:28:18,240 --> 00:28:20,320
regardless i'm using a mutex instead

887
00:28:20,320 --> 00:28:22,159
and it works just as well then we go

888
00:28:22,159 --> 00:28:23,520
ahead and break the loop

889
00:28:23,520 --> 00:28:26,240
uh do a cuda device reset and return

890
00:28:26,240 --> 00:28:26,640
null

891
00:28:26,640 --> 00:28:28,399
but i also just quickly checked that hey

892
00:28:28,399 --> 00:28:30,399
if another gpu handler thread's found a

893
00:28:30,399 --> 00:28:31,760
solution then there's no need for me to

894
00:28:31,760 --> 00:28:32,720
continue to compute

895
00:28:32,720 --> 00:28:34,960
so i can just break cuda device reset

896
00:28:34,960 --> 00:28:37,440
return null we're good to go

897
00:28:37,440 --> 00:28:39,600
and so uh the way this works is is

898
00:28:39,600 --> 00:28:41,039
pretty fascinating and then of course

899
00:28:41,039 --> 00:28:42,080
we've got the main function

900
00:28:42,080 --> 00:28:43,520
and the main function is basically just

901
00:28:43,520 --> 00:28:44,720
going to do a little bit of

902
00:28:44,720 --> 00:28:46,399
initialization we're going to

903
00:28:46,399 --> 00:28:48,080
uh go ahead and initialize the solution

904
00:28:48,080 --> 00:28:49,600
lock as i mentioned here's the first

905
00:28:49,600 --> 00:28:50,799
lock so this one's easy

906
00:28:50,799 --> 00:28:52,720
you know it's by default unlocked main

907
00:28:52,720 --> 00:28:54,880
thread locks it it's got lock

908
00:28:54,880 --> 00:28:56,559
um but then from there what it's going

909
00:28:56,559 --> 00:28:58,080
to do is it's going

910
00:28:58,080 --> 00:29:00,880
to initialize two arrays it's going to

911
00:29:00,880 --> 00:29:02,720
initialize an array of thread

912
00:29:02,720 --> 00:29:03,760
identifiers

913
00:29:03,760 --> 00:29:05,360
so this is so that we know the thread

914
00:29:05,360 --> 00:29:07,039
ids for our

915
00:29:07,039 --> 00:29:08,960
handler threads so we can kill them at

916
00:29:08,960 --> 00:29:11,120
the end or join with them at the end

917
00:29:11,120 --> 00:29:13,600
and also an array of pointers so a

918
00:29:13,600 --> 00:29:14,880
double pointer

919
00:29:14,880 --> 00:29:17,360
and these this array of pointers uh each

920
00:29:17,360 --> 00:29:17,919
element

921
00:29:17,919 --> 00:29:20,399
actually points to the part of the

922
00:29:20,399 --> 00:29:22,159
handler input struct

923
00:29:22,159 --> 00:29:24,080
that defines the number of hashes that

924
00:29:24,080 --> 00:29:26,240
were processed by that gpu

925
00:29:26,240 --> 00:29:27,520
and of course we're using this so we

926
00:29:27,520 --> 00:29:29,440
actually can tell from the main thread

927
00:29:29,440 --> 00:29:32,720
uh how many hashes were processed now i

928
00:29:32,720 --> 00:29:34,480
also go ahead and calculate the start

929
00:29:34,480 --> 00:29:35,200
time

930
00:29:35,200 --> 00:29:37,120
once again this is for benchmarking so

931
00:29:37,120 --> 00:29:39,039
we can see you know how many seconds it

932
00:29:39,039 --> 00:29:40,000
takes for the gpus

933
00:29:40,000 --> 00:29:42,960
to actually do their do their magic um

934
00:29:42,960 --> 00:29:43,760
and then i just

935
00:29:43,760 --> 00:29:46,799
loop from zero to the number of gpus

936
00:29:46,799 --> 00:29:51,600
i go ahead and create the handler input

937
00:29:51,600 --> 00:29:54,159
block of memory i allocate that i set

938
00:29:54,159 --> 00:29:55,200
the device

939
00:29:55,200 --> 00:29:58,159
using the loop in index i go ahead and

940
00:29:58,159 --> 00:29:59,440
set the number of hashes that have been

941
00:29:59,440 --> 00:30:01,600
processed to zero by default

942
00:30:01,600 --> 00:30:03,440
i could absolutely use call lock but

943
00:30:03,440 --> 00:30:05,760
that takes a bit of extra overhead

944
00:30:05,760 --> 00:30:08,399
let's not talk about that right now and

945
00:30:08,399 --> 00:30:10,799
i also go ahead and take a pointer

946
00:30:10,799 --> 00:30:12,720
to the part of the structure that

947
00:30:12,720 --> 00:30:14,640
defines the hashes that were processed

948
00:30:14,640 --> 00:30:16,480
put it in that first array i was talking

949
00:30:16,480 --> 00:30:19,120
about then i go ahead

950
00:30:19,120 --> 00:30:21,840
and tell p thread to create a thread and

951
00:30:21,840 --> 00:30:24,000
i tell it to put the thread id directly

952
00:30:24,000 --> 00:30:26,880
inside of the array of thread ids

953
00:30:26,880 --> 00:30:28,559
and i of course pass it the handler

954
00:30:28,559 --> 00:30:30,720
input if you take a look here

955
00:30:30,720 --> 00:30:34,159
we are passing it handler input

956
00:30:34,159 --> 00:30:35,520
for the thread and then just go ahead

957
00:30:35,520 --> 00:30:37,039
and sleep a little bit and the reason

958
00:30:37,039 --> 00:30:38,720
for the sleep is actually important

959
00:30:38,720 --> 00:30:40,399
because if you launch the threads too

960
00:30:40,399 --> 00:30:42,000
quickly and they calculate their time in

961
00:30:42,000 --> 00:30:43,600
milliseconds at the same time

962
00:30:43,600 --> 00:30:45,200
they're both gonna have the same random

963
00:30:45,200 --> 00:30:47,200
seed and the same you know for the

964
00:30:47,200 --> 00:30:48,240
random seats

965
00:30:48,240 --> 00:30:49,919
and so you're again going to be doing

966
00:30:49,919 --> 00:30:51,760
nothing and there's no point of that

967
00:30:51,760 --> 00:30:53,840
um so i make sure that i sleep for a

968
00:30:53,840 --> 00:30:55,520
little bit uh so that we have different

969
00:30:55,520 --> 00:30:56,880
random c's

970
00:30:56,880 --> 00:30:58,559
then what i do is i have an infinite

971
00:30:58,559 --> 00:31:00,480
loop and this is pretty fun

972
00:31:00,480 --> 00:31:03,120
logic over here what i do is i actually

973
00:31:03,120 --> 00:31:04,080
go ahead and loop

974
00:31:04,080 --> 00:31:05,840
through all of those pointers to the

975
00:31:05,840 --> 00:31:07,679
handler input structures

976
00:31:07,679 --> 00:31:11,200
and i go ahead and essentially what i do

977
00:31:11,200 --> 00:31:11,519
is i

978
00:31:11,519 --> 00:31:13,519
i take the values that they point to so

979
00:31:13,519 --> 00:31:14,880
the number of hashes that were processed

980
00:31:14,880 --> 00:31:15,279
get a

981
00:31:15,279 --> 00:31:17,600
sum of all the handler input functions

982
00:31:17,600 --> 00:31:19,840
or handler inputs

983
00:31:19,840 --> 00:31:22,000
and then i go ahead and sum them i take

984
00:31:22,000 --> 00:31:23,600
the elapsed time

985
00:31:23,600 --> 00:31:26,960
and i print out in real time how many

986
00:31:26,960 --> 00:31:28,480
hashes have been processed how many

987
00:31:28,480 --> 00:31:29,760
seconds have elapsed

988
00:31:29,760 --> 00:31:31,840
and the current hashes per second count

989
00:31:31,840 --> 00:31:32,799
so this is something that's going to

990
00:31:32,799 --> 00:31:35,039
continuously update even as

991
00:31:35,039 --> 00:31:37,360
we are calculating a solution even as

992
00:31:37,360 --> 00:31:39,519
we're brute forcing a solution

993
00:31:39,519 --> 00:31:40,799
and this is the advantage of having a

994
00:31:40,799 --> 00:31:42,399
separate main thread and separate

995
00:31:42,399 --> 00:31:43,679
handler threads

996
00:31:43,679 --> 00:31:45,600
then i just have a little logic that

997
00:31:45,600 --> 00:31:47,360
says if we found a solution and it's no

998
00:31:47,360 --> 00:31:48,960
longer uninitialized memory

999
00:31:48,960 --> 00:31:51,120
then break the loop print out a new line

1000
00:31:51,120 --> 00:31:52,399
so we can um

1001
00:31:52,399 --> 00:31:54,720
separate then just for the sake of

1002
00:31:54,720 --> 00:31:56,080
safety

1003
00:31:56,080 --> 00:31:57,760
lock the solution lock again that's

1004
00:31:57,760 --> 00:31:59,120
really important we don't want to be

1005
00:31:59,120 --> 00:31:59,840
reading on the

1006
00:31:59,840 --> 00:32:02,080
uninitialized memory so we go ahead and

1007
00:32:02,080 --> 00:32:04,240
lock it again and that's only possible

1008
00:32:04,240 --> 00:32:06,399
after the handler thread is unlocked

1009
00:32:06,399 --> 00:32:07,600
meaning the main thread locks it

1010
00:32:07,600 --> 00:32:08,480
immediately

1011
00:32:08,480 --> 00:32:10,960
and we're good to go and then go ahead

1012
00:32:10,960 --> 00:32:14,320
and calculate a final elapsed time count

1013
00:32:14,320 --> 00:32:16,960
i go ahead and join with all gpu handler

1014
00:32:16,960 --> 00:32:18,080
threads

1015
00:32:18,080 --> 00:32:19,519
and then from there i just go ahead and

1016
00:32:19,519 --> 00:32:21,120
calculate finally the number of hashes

1017
00:32:21,120 --> 00:32:22,240
that were processed

1018
00:32:22,240 --> 00:32:23,760
and then i print out the solution i

1019
00:32:23,760 --> 00:32:25,039
print out the total number of hashes

1020
00:32:25,039 --> 00:32:25,760
processed

1021
00:32:25,760 --> 00:32:28,000
the time that it took and the hashes

1022
00:32:28,000 --> 00:32:30,320
that were processed per second

1023
00:32:30,320 --> 00:32:32,799
as you can tell this is a really really

1024
00:32:32,799 --> 00:32:33,840
fun dance between

1025
00:32:33,840 --> 00:32:36,799
cpu and gpu and and processing on all

1026
00:32:36,799 --> 00:32:38,799
sorts of different devices

1027
00:32:38,799 --> 00:32:40,159
and now that you understand the overall

1028
00:32:40,159 --> 00:32:41,440
architecture we can come back to the

1029
00:32:41,440 --> 00:32:43,279
cuda kernel that i was promising

1030
00:32:43,279 --> 00:32:45,279
the kuda kernel remember is a single

1031
00:32:45,279 --> 00:32:47,519
function and this is invoked

1032
00:32:47,519 --> 00:32:50,720
once per thread and

1033
00:32:50,720 --> 00:32:52,159
and remember there are multiple blocks

1034
00:32:52,159 --> 00:32:54,480
of threads so this function is actually

1035
00:32:54,480 --> 00:32:55,600
called

1036
00:32:55,600 --> 00:32:58,799
thousands of times every time we invoke

1037
00:32:58,799 --> 00:33:02,399
the cuda kernel and in order to know

1038
00:33:02,399 --> 00:33:04,559
which thread you want you are in this

1039
00:33:04,559 --> 00:33:07,760
function there's a bunch of global or

1040
00:33:07,760 --> 00:33:10,799
system variables here like block index

1041
00:33:10,799 --> 00:33:13,440
block dimension and thread index by

1042
00:33:13,440 --> 00:33:15,120
leveraging those you can know which

1043
00:33:15,120 --> 00:33:16,240
thread you are

1044
00:33:16,240 --> 00:33:18,159
that's important for me because by

1045
00:33:18,159 --> 00:33:19,679
knowing which thread i am

1046
00:33:19,679 --> 00:33:21,919
i can modify my random c to be different

1047
00:33:21,919 --> 00:33:24,240
from every other thread's random seed

1048
00:33:24,240 --> 00:33:26,080
and therefore we actually have gpus

1049
00:33:26,080 --> 00:33:27,440
doing compute

1050
00:33:27,440 --> 00:33:30,399
and not nonsense and so then what i do

1051
00:33:30,399 --> 00:33:31,679
is pretty simple stuff go ahead and

1052
00:33:31,679 --> 00:33:34,240
initialize the shot 256 context

1053
00:33:34,240 --> 00:33:36,159
create the digest and this is a block of

1054
00:33:36,159 --> 00:33:38,559
32 bytes which represents the final shot

1055
00:33:38,559 --> 00:33:39,360
256

1056
00:33:39,360 --> 00:33:41,440
hash go ahead and create the random

1057
00:33:41,440 --> 00:33:44,000
bytes create the random seed add in the

1058
00:33:44,000 --> 00:33:45,519
thread index

1059
00:33:45,519 --> 00:33:47,760
then go ahead and generate the random

1060
00:33:47,760 --> 00:33:49,840
string by looping

1061
00:33:49,840 --> 00:33:52,000
then finally go ahead and initialize the

1062
00:33:52,000 --> 00:33:53,200
context

1063
00:33:53,200 --> 00:33:55,039
update it with the prefix so go ahead

1064
00:33:55,039 --> 00:33:57,679
and calculate the sha 256 for the prefix

1065
00:33:57,679 --> 00:34:00,240
um calculate the sha-256 for the random

1066
00:34:00,240 --> 00:34:01,440
string that you append

1067
00:34:01,440 --> 00:34:04,000
and then go ahead and finalize that hash

1068
00:34:04,000 --> 00:34:06,480
and store it within the digest

1069
00:34:06,480 --> 00:34:08,159
once that's done we have a little bit of

1070
00:34:08,159 --> 00:34:10,720
difficulty verification going on

1071
00:34:10,720 --> 00:34:13,040
and so all i need to do is just loop

1072
00:34:13,040 --> 00:34:14,000
through

1073
00:34:14,000 --> 00:34:15,679
four bytes because we're referring to

1074
00:34:15,679 --> 00:34:17,520
difficulty which is referred to as four

1075
00:34:17,520 --> 00:34:19,119
so loop through four bytes make sure

1076
00:34:19,119 --> 00:34:20,800
they're all zero if

1077
00:34:20,800 --> 00:34:22,639
if any one isn't zero just return

1078
00:34:22,639 --> 00:34:24,159
immediately right we know

1079
00:34:24,159 --> 00:34:26,320
we don't have a solution just return but

1080
00:34:26,320 --> 00:34:27,679
if it did pass that

1081
00:34:27,679 --> 00:34:30,879
then we have another test the other test

1082
00:34:30,879 --> 00:34:33,599
is uh check four more bits so not a

1083
00:34:33,599 --> 00:34:35,440
whole byte more just half a byte

1084
00:34:35,440 --> 00:34:38,480
so in total we're looking for 36 bits of

1085
00:34:38,480 --> 00:34:39,520
zeros to begin with

1086
00:34:39,520 --> 00:34:41,040
that's a magic number it can be really

1087
00:34:41,040 --> 00:34:42,800
whatever you want it to be

1088
00:34:42,800 --> 00:34:45,919
the less the more easy it is for for the

1089
00:34:45,919 --> 00:34:47,760
algorithm to find a solution

1090
00:34:47,760 --> 00:34:49,919
but in this case it's enough to be

1091
00:34:49,919 --> 00:34:50,800
challenging

1092
00:34:50,800 --> 00:34:53,919
um and that's the entire point

1093
00:34:53,919 --> 00:34:55,359
in fact i'm actually going to make this

1094
00:34:55,359 --> 00:34:57,200
a bit more difficult right let's bump it

1095
00:34:57,200 --> 00:34:58,800
up a little bit

1096
00:34:58,800 --> 00:35:01,839
from from from 36. then of course i go

1097
00:35:01,839 --> 00:35:02,560
ahead and do a

1098
00:35:02,560 --> 00:35:04,880
final check if we've reached this line

1099
00:35:04,880 --> 00:35:05,599
of code

1100
00:35:05,599 --> 00:35:08,079
we know we have a solution on our hands

1101
00:35:08,079 --> 00:35:10,079
but if another threads already found a

1102
00:35:10,079 --> 00:35:11,119
solution

1103
00:35:11,119 --> 00:35:14,000
just return don't copy your own memory

1104
00:35:14,000 --> 00:35:14,480
and

1105
00:35:14,480 --> 00:35:16,160
then go ahead and just immediately say

1106
00:35:16,160 --> 00:35:18,000
you know what i found a solution

1107
00:35:18,000 --> 00:35:20,480
uh and then from there go ahead and copy

1108
00:35:20,480 --> 00:35:21,440
this thread's

1109
00:35:21,440 --> 00:35:24,160
solution to the memory that is allocated

1110
00:35:24,160 --> 00:35:26,160
specifically for the purpose

1111
00:35:26,160 --> 00:35:29,280
of storing the solution and with that

1112
00:35:29,280 --> 00:35:31,280
we're done that's that's all there is to

1113
00:35:31,280 --> 00:35:33,280
it i know it seems like

1114
00:35:33,280 --> 00:35:35,440
wow we colored an entire gpu in just

1115
00:35:35,440 --> 00:35:36,960
that much code but yeah we did it and

1116
00:35:36,960 --> 00:35:38,320
that's the power of cuda that's why we

1117
00:35:38,320 --> 00:35:39,839
use cuda over things like

1118
00:35:39,839 --> 00:35:42,240
opencl or metal it's just genuinely more

1119
00:35:42,240 --> 00:35:44,560
intuitive and easy and powerful to get

1120
00:35:44,560 --> 00:35:46,400
things done with cuda

1121
00:35:46,400 --> 00:35:47,760
not to say that you can't get things

1122
00:35:47,760 --> 00:35:49,920
done with opencl or metal or vulcan or

1123
00:35:49,920 --> 00:35:51,200
whatever else you want to use

1124
00:35:51,200 --> 00:35:52,960
but cuda's been developed from the very

1125
00:35:52,960 --> 00:35:56,560
beginning to be great at gp gpu

1126
00:35:56,560 --> 00:35:57,920
and it really shows in the way that we

1127
00:35:57,920 --> 00:35:59,680
can code with it

1128
00:35:59,680 --> 00:36:02,320
so now if i go ahead and exit vim we can

1129
00:36:02,320 --> 00:36:03,839
go ahead and have some fun

1130
00:36:03,839 --> 00:36:05,680
so i'm going to go ahead and use nvcc

1131
00:36:05,680 --> 00:36:08,000
which is the nvidia seat cuda compiler

1132
00:36:08,000 --> 00:36:11,520
uh to compile uh my code now i do

1133
00:36:11,520 --> 00:36:13,920
want to tell nvcc to run full

1134
00:36:13,920 --> 00:36:15,359
optimizations like as

1135
00:36:15,359 --> 00:36:18,160
as as high as it can get um and these

1136
00:36:18,160 --> 00:36:18,640
two

1137
00:36:18,640 --> 00:36:20,240
flags that i pass it are telling it

1138
00:36:20,240 --> 00:36:21,680
basically go

1139
00:36:21,680 --> 00:36:23,760
all out with your optimizations don't

1140
00:36:23,760 --> 00:36:24,800
hold back

1141
00:36:24,800 --> 00:36:27,280
um now it doesn't have an o fast flag

1142
00:36:27,280 --> 00:36:29,200
like clang and gcc it just has up till

1143
00:36:29,200 --> 00:36:31,359
o3 so we're using o3

1144
00:36:31,359 --> 00:36:33,200
but now if you take a look we have a

1145
00:36:33,200 --> 00:36:35,680
compiled binary and watch this this is

1146
00:36:35,680 --> 00:36:38,160
so fun what it's going to do is it's

1147
00:36:38,160 --> 00:36:40,640
going to start in real time printing out

1148
00:36:40,640 --> 00:36:42,160
the number of hashes in total that have

1149
00:36:42,160 --> 00:36:43,520
been processed the number of seconds

1150
00:36:43,520 --> 00:36:44,400
that have elapsed

1151
00:36:44,400 --> 00:36:45,839
and the hashes that are being processed

1152
00:36:45,839 --> 00:36:47,520
per second watch this

1153
00:36:47,520 --> 00:36:49,440
it takes a few milliseconds to actually

1154
00:36:49,440 --> 00:36:51,760
initialize but once it initializes

1155
00:36:51,760 --> 00:36:54,560
you can see that it just gets going like

1156
00:36:54,560 --> 00:36:56,000
take a look at that

1157
00:36:56,000 --> 00:36:58,320
wow we've already processed in the

1158
00:36:58,320 --> 00:37:00,000
amount of time that i said this over 100

1159
00:37:00,000 --> 00:37:01,119
billion hashes

1160
00:37:01,119 --> 00:37:03,440
it's hot it's processing 8 billion per

1161
00:37:03,440 --> 00:37:04,240
second and

1162
00:37:04,240 --> 00:37:06,240
counting the most that i've seen this

1163
00:37:06,240 --> 00:37:08,240
peak at is about 8.3

1164
00:37:08,240 --> 00:37:11,359
billion per second that is incredible

1165
00:37:11,359 --> 00:37:12,720
and so what we're going to do is let

1166
00:37:12,720 --> 00:37:14,960
this go yes look at that 8.2

1167
00:37:14,960 --> 00:37:18,000
8.23 8.24 8.25

1168
00:37:18,000 --> 00:37:19,520
of course there's diminishing returns as

1169
00:37:19,520 --> 00:37:21,359
you get higher and higher and the reason

1170
00:37:21,359 --> 00:37:22,320
for that is is

1171
00:37:22,320 --> 00:37:23,839
one of the reasons at least is that

1172
00:37:23,839 --> 00:37:25,440
remember there's that initialization

1173
00:37:25,440 --> 00:37:26,079
cost in

1174
00:37:26,079 --> 00:37:28,640
in the beginning and so as you continue

1175
00:37:28,640 --> 00:37:30,079
to process more and more hashes

1176
00:37:30,079 --> 00:37:33,280
you're compounding um that um

1177
00:37:33,280 --> 00:37:35,280
and you're sort of reducing that initial

1178
00:37:35,280 --> 00:37:38,640
cost on the number of hashes per second

1179
00:37:38,640 --> 00:37:41,520
oh wow we're eight point three six eight

1180
00:37:41,520 --> 00:37:43,200
point three seven we're going further

1181
00:37:43,200 --> 00:37:44,880
we might we might actually get to eight

1182
00:37:44,880 --> 00:37:47,119
point four uh now remember if your

1183
00:37:47,119 --> 00:37:49,440
problem is too simple then it's always

1184
00:37:49,440 --> 00:37:51,520
possible that you will find a solution

1185
00:37:51,520 --> 00:37:53,680
so quickly that you will not be

1186
00:37:53,680 --> 00:37:55,440
processing very many hashes per second

1187
00:37:55,440 --> 00:37:57,280
because the initialization cost was too

1188
00:37:57,280 --> 00:37:58,320
high

1189
00:37:58,320 --> 00:38:01,040
but oh we reached 8.4 this is actually a

1190
00:38:01,040 --> 00:38:02,480
pretty tough problem for it to solve

1191
00:38:02,480 --> 00:38:03,440
maybe we need to re

1192
00:38:03,440 --> 00:38:05,119
crank down the difficulty a bit but

1193
00:38:05,119 --> 00:38:06,560
actually what i want to do is i want to

1194
00:38:06,560 --> 00:38:08,240
let it go ahead and solve it on its own

1195
00:38:08,240 --> 00:38:10,320
we're about to hit a trillion hashes in

1196
00:38:10,320 --> 00:38:11,280
just a moment

1197
00:38:11,280 --> 00:38:13,760
uh so i'm going to go ahead and speed up

1198
00:38:13,760 --> 00:38:14,720
the video

1199
00:38:14,720 --> 00:38:17,040
and we're going to go ahead and wait for

1200
00:38:17,040 --> 00:38:18,720
a solution to this problem i'll be right

1201
00:38:18,720 --> 00:38:20,960
back

1202
00:38:23,040 --> 00:38:24,560
all right so now let's take a look as

1203
00:38:24,560 --> 00:38:26,240
you can see we processed

1204
00:38:26,240 --> 00:38:29,960
a trillion 59 billion 79 million

1205
00:38:29,960 --> 00:38:33,200
680 000 hashes

1206
00:38:33,200 --> 00:38:35,119
that is mind-boggling the fact that we

1207
00:38:35,119 --> 00:38:37,359
did it in just two minutes and five

1208
00:38:37,359 --> 00:38:39,280
seconds

1209
00:38:39,280 --> 00:38:42,240
wow okay um we found the solution to the

1210
00:38:42,240 --> 00:38:43,200
problem which is

1211
00:38:43,200 --> 00:38:46,560
amazing uh and we we can see our final

1212
00:38:46,560 --> 00:38:48,480
hashes per second count over here

1213
00:38:48,480 --> 00:38:50,240
of course this is slightly lower than it

1214
00:38:50,240 --> 00:38:51,839
was over here because there was

1215
00:38:51,839 --> 00:38:53,920
not only the extra initialization cost

1216
00:38:53,920 --> 00:38:56,000
now but also the extra cost of

1217
00:38:56,000 --> 00:38:57,520
winding everything down and having a

1218
00:38:57,520 --> 00:39:00,720
graceful shutdown now what's incredible

1219
00:39:00,720 --> 00:39:02,079
is that we could literally just go ahead

1220
00:39:02,079 --> 00:39:03,119
and go to any

1221
00:39:03,119 --> 00:39:05,760
like sha 256 hashing algorithm or

1222
00:39:05,760 --> 00:39:06,720
implementation

1223
00:39:06,720 --> 00:39:08,480
uh feed intane a back sheet and just

1224
00:39:08,480 --> 00:39:10,720
append this one string to it

1225
00:39:10,720 --> 00:39:12,720
and suddenly you would have it start off

1226
00:39:12,720 --> 00:39:14,000
with a certain number of

1227
00:39:14,000 --> 00:39:16,720
zeros more than 36 bits in the beginning

1228
00:39:16,720 --> 00:39:17,599
would start

1229
00:39:17,599 --> 00:39:20,000
with zero that is truly incredible what

1230
00:39:20,000 --> 00:39:21,680
i quickly do want to do

1231
00:39:21,680 --> 00:39:24,000
um is i want to modify the code and just

1232
00:39:24,000 --> 00:39:24,800
show you

1233
00:39:24,800 --> 00:39:26,960
what happens if we go down to one gpu

1234
00:39:26,960 --> 00:39:28,320
see it's only one gpu and we're going to

1235
00:39:28,320 --> 00:39:30,240
reduce the difficulty to like

1236
00:39:30,240 --> 00:39:32,480
three just so that we can speed this up

1237
00:39:32,480 --> 00:39:33,599
a little

1238
00:39:33,599 --> 00:39:35,839
and if you take a look what happens if i

1239
00:39:35,839 --> 00:39:38,160
go ahead and compile this

1240
00:39:38,160 --> 00:39:40,400
and if i go ahead and run this code

1241
00:39:40,400 --> 00:39:41,280
watch this

1242
00:39:41,280 --> 00:39:43,200
it's gonna find a solution and well

1243
00:39:43,200 --> 00:39:45,280
maybe that was a bit too simple

1244
00:39:45,280 --> 00:39:47,599
um but i'll just bring it down to like

1245
00:39:47,599 --> 00:39:48,400
four

1246
00:39:48,400 --> 00:39:52,000
um this will take a second um

1247
00:39:52,000 --> 00:39:53,760
and then go ahead and comment up this

1248
00:39:53,760 --> 00:39:56,560
line of code over here

1249
00:39:56,560 --> 00:39:59,040
and watch this what's really fascinating

1250
00:39:59,040 --> 00:40:00,960
about this

1251
00:40:00,960 --> 00:40:02,960
what's really fascinating is that the

1252
00:40:02,960 --> 00:40:05,119
scaling is nearly linear

1253
00:40:05,119 --> 00:40:07,760
well see this problem is wait there we

1254
00:40:07,760 --> 00:40:08,800
go see

1255
00:40:08,800 --> 00:40:10,160
finally i was able to demonstrate the

1256
00:40:10,160 --> 00:40:12,160
linear scaling you see what's amazing is

1257
00:40:12,160 --> 00:40:14,160
that just a single gpu is reaching about

1258
00:40:14,160 --> 00:40:16,480
two billion hashes per second

1259
00:40:16,480 --> 00:40:18,480
and if we go ahead and take four gpus

1260
00:40:18,480 --> 00:40:20,480
worth which is like 8.4 billion

1261
00:40:20,480 --> 00:40:22,800
and if we divide this by four we notice

1262
00:40:22,800 --> 00:40:24,960
that it's 2.1 billion hashes per second

1263
00:40:24,960 --> 00:40:26,000
so this specific

1264
00:40:26,000 --> 00:40:27,680
use case is such that because there's no

1265
00:40:27,680 --> 00:40:29,280
communication across gpus and things

1266
00:40:29,280 --> 00:40:30,160
like that

1267
00:40:30,160 --> 00:40:33,040
it scales linearly it's absolutely

1268
00:40:33,040 --> 00:40:35,119
incredible the way this technology works

1269
00:40:35,119 --> 00:40:36,960
and it's only possible thanks to the

1270
00:40:36,960 --> 00:40:38,880
power of cuda

1271
00:40:38,880 --> 00:40:40,240
and so that brings us to the end of

1272
00:40:40,240 --> 00:40:41,920
today's tutorial i really do hope you

1273
00:40:41,920 --> 00:40:43,440
enjoyed and i hope this was insightful

1274
00:40:43,440 --> 00:40:44,480
and helped you learn a little bit more

1275
00:40:44,480 --> 00:40:46,640
about the world of cuda how it works

1276
00:40:46,640 --> 00:40:48,319
and how some of the algorithms behind

1277
00:40:48,319 --> 00:40:50,480
the world of blockchain work as well

1278
00:40:50,480 --> 00:40:51,680
now of course if you do like it this

1279
00:40:51,680 --> 00:40:53,040
kind of content please do make sure you

1280
00:40:53,040 --> 00:40:54,319
subscribe to the channel as it really

1281
00:40:54,319 --> 00:40:55,760
does help out a lot

1282
00:40:55,760 --> 00:40:58,079
uh and of course do do turn on

1283
00:40:58,079 --> 00:40:59,520
notifications and that way

1284
00:40:59,520 --> 00:41:01,200
you're actually notified whenever i go

1285
00:41:01,200 --> 00:41:03,359
ahead and release new content

1286
00:41:03,359 --> 00:41:05,599
uh and with that uh please do feel free

1287
00:41:05,599 --> 00:41:07,359
to leave any questions or suggestions

1288
00:41:07,359 --> 00:41:08,800
you have down in the comments below or

1289
00:41:08,800 --> 00:41:10,160
reach out to me on social media and i

1290
00:41:10,160 --> 00:41:11,680
would love to answer them

1291
00:41:11,680 --> 00:41:13,599
and the code is on github and in the

1292
00:41:13,599 --> 00:41:14,960
description all right thank you very

1293
00:41:14,960 --> 00:41:18,800
much everybody goodbye
