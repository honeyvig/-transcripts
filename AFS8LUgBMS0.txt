1
00:00:00,320 --> 00:00:02,240
so hello there and welcome to another

2
00:00:02,240 --> 00:00:04,560
tutorial my name is tanmay bakshi and

3
00:00:04,560 --> 00:00:05,120
today

4
00:00:05,120 --> 00:00:06,799
we're going to be diving into the world

5
00:00:06,799 --> 00:00:08,800
of k-means clustering and a little bit

6
00:00:08,800 --> 00:00:10,400
of unsupervised learning

7
00:00:10,400 --> 00:00:12,080
now before we get deeper into this i do

8
00:00:12,080 --> 00:00:13,519
want to start off by saying that if you

9
00:00:13,519 --> 00:00:14,880
do enjoy this kind of content and you

10
00:00:14,880 --> 00:00:15,839
want to see more of it

11
00:00:15,839 --> 00:00:17,440
please do make sure to subscribe to the

12
00:00:17,440 --> 00:00:19,119
channel and turn on notifications as

13
00:00:19,119 --> 00:00:20,560
well as like the video

14
00:00:20,560 --> 00:00:22,000
of course if you have any questions

15
00:00:22,000 --> 00:00:23,519
suggestions or feedback feel free to

16
00:00:23,519 --> 00:00:24,880
leave it down in the comment section

17
00:00:24,880 --> 00:00:26,160
below or reach out to me

18
00:00:26,160 --> 00:00:27,760
and i'd love to go ahead and answer your

19
00:00:27,760 --> 00:00:29,519
questions and hear what you have to say

20
00:00:29,519 --> 00:00:31,439
now diving right into the world of

21
00:00:31,439 --> 00:00:33,280
k-means clustering this is a really

22
00:00:33,280 --> 00:00:34,960
interesting algorithm

23
00:00:34,960 --> 00:00:37,360
effectively it's a family uh it's within

24
00:00:37,360 --> 00:00:39,200
the family of unsupervised learning

25
00:00:39,200 --> 00:00:40,000
algorithms

26
00:00:40,000 --> 00:00:42,000
which are algorithms that don't require

27
00:00:42,000 --> 00:00:44,239
labeled data to learn

28
00:00:44,239 --> 00:00:45,840
so you may have experience training deep

29
00:00:45,840 --> 00:00:47,520
neural networks for example and these

30
00:00:47,520 --> 00:00:49,039
deep neural networks require

31
00:00:49,039 --> 00:00:51,120
mappings of data so for example you

32
00:00:51,120 --> 00:00:52,800
could say here's an image of a cat

33
00:00:52,800 --> 00:00:54,559
and here's an image of a dog you can't

34
00:00:54,559 --> 00:00:56,160
just give it the images you need to also

35
00:00:56,160 --> 00:00:57,440
provide it with labels

36
00:00:57,440 --> 00:00:59,359
that's called supervised learning

37
00:00:59,359 --> 00:01:00,640
unsupervised learning

38
00:01:00,640 --> 00:01:02,160
is when you get to feed the model with

39
00:01:02,160 --> 00:01:03,920
your data and have it extract the

40
00:01:03,920 --> 00:01:05,119
insights for you

41
00:01:05,119 --> 00:01:07,119
you don't manually give it some sort of

42
00:01:07,119 --> 00:01:09,439
information about that data

43
00:01:09,439 --> 00:01:11,040
now within this world of unsupervised

44
00:01:11,040 --> 00:01:12,720
learning k-means clustering is one of

45
00:01:12,720 --> 00:01:12,960
the

46
00:01:12,960 --> 00:01:15,040
i guess most classic algorithms the one

47
00:01:15,040 --> 00:01:16,560
that a lot of people implement

48
00:01:16,560 --> 00:01:18,479
and it's one of those where i've used it

49
00:01:18,479 --> 00:01:21,040
before actually a lot of times

50
00:01:21,040 --> 00:01:22,880
but i've never had to implement it from

51
00:01:22,880 --> 00:01:24,240
scratch myself

52
00:01:24,240 --> 00:01:26,400
a couple of days ago i had the excuse to

53
00:01:26,400 --> 00:01:27,920
implement it myself

54
00:01:27,920 --> 00:01:30,479
and i must say i am surprised by just

55
00:01:30,479 --> 00:01:32,479
how simple the algorithm is

56
00:01:32,479 --> 00:01:35,600
in the back end effectively the way that

57
00:01:35,600 --> 00:01:37,200
k-means clustering works

58
00:01:37,200 --> 00:01:39,040
is you start off with your data this can

59
00:01:39,040 --> 00:01:41,200
be in practically any dimensional space

60
00:01:41,200 --> 00:01:42,960
uh in this simple example we're going to

61
00:01:42,960 --> 00:01:44,960
be using two dimensional uh points

62
00:01:44,960 --> 00:01:46,799
however you could have n-dimensional

63
00:01:46,799 --> 00:01:48,399
points so if you have output from a

64
00:01:48,399 --> 00:01:49,560
neural network that's

65
00:01:49,560 --> 00:01:51,920
10-24-dimensional say from burt large

66
00:01:51,920 --> 00:01:53,759
you can absolutely still use k-means

67
00:01:53,759 --> 00:01:54,640
clustering

68
00:01:54,640 --> 00:01:55,439
but let's just say you have

69
00:01:55,439 --> 00:01:57,520
two-dimensional data effectively all you

70
00:01:57,520 --> 00:01:58,320
need to do

71
00:01:58,320 --> 00:02:00,399
is come up with some random points for

72
00:02:00,399 --> 00:02:02,640
your centroids which are the centers

73
00:02:02,640 --> 00:02:04,719
of the clusters that k-means clustering

74
00:02:04,719 --> 00:02:05,680
identifies

75
00:02:05,680 --> 00:02:07,920
once you have random points for them you

76
00:02:07,920 --> 00:02:08,879
identify which

77
00:02:08,879 --> 00:02:11,440
points within your actual data belong to

78
00:02:11,440 --> 00:02:12,560
which centroids

79
00:02:12,560 --> 00:02:14,319
which means which ones are they closest

80
00:02:14,319 --> 00:02:16,000
to you'll usually use something like

81
00:02:16,000 --> 00:02:17,760
euclidean distance for this

82
00:02:17,760 --> 00:02:20,000
and then all you do is you now figure

83
00:02:20,000 --> 00:02:22,400
out which points are actually associated

84
00:02:22,400 --> 00:02:23,840
with which centroids

85
00:02:23,840 --> 00:02:26,400
and then you calculate the average of

86
00:02:26,400 --> 00:02:27,760
those points

87
00:02:27,760 --> 00:02:29,599
and you move the centroid towards the

88
00:02:29,599 --> 00:02:31,840
average that's all there is to it

89
00:02:31,840 --> 00:02:33,920
and suddenly you'll be able to group

90
00:02:33,920 --> 00:02:35,360
your data into

91
00:02:35,360 --> 00:02:37,760
n different clusters where n is however

92
00:02:37,760 --> 00:02:38,400
many

93
00:02:38,400 --> 00:02:40,319
clusters you're looking for now

94
00:02:40,319 --> 00:02:42,879
determining how many clusters to use

95
00:02:42,879 --> 00:02:44,879
is another issue altogether in some

96
00:02:44,879 --> 00:02:46,879
cases you may already know the count

97
00:02:46,879 --> 00:02:48,400
so for example if we're using mnist

98
00:02:48,400 --> 00:02:50,400
digits we know that we want

99
00:02:50,400 --> 00:02:52,160
10 clusters because there's 10 different

100
00:02:52,160 --> 00:02:54,239
digits but because this is unsupervised

101
00:02:54,239 --> 00:02:55,760
learning in a lot of cases you wouldn't

102
00:02:55,760 --> 00:02:56,239
actually

103
00:02:56,239 --> 00:02:58,560
know how many clusters you need you can

104
00:02:58,560 --> 00:03:00,959
do things like elbow analysis here

105
00:03:00,959 --> 00:03:03,519
however what we're going to be doing is

106
00:03:03,519 --> 00:03:06,400
simply focusing on the k-means algorithm

107
00:03:06,400 --> 00:03:08,400
how it works and how you can implement

108
00:03:08,400 --> 00:03:10,159
it from scratch in python

109
00:03:10,159 --> 00:03:11,440
and so now let's go ahead and take a

110
00:03:11,440 --> 00:03:13,599
look at actually implementing k-means

111
00:03:13,599 --> 00:03:15,440
from scratch it's only a couple of lines

112
00:03:15,440 --> 00:03:17,120
of code and it'll give you a bit more of

113
00:03:17,120 --> 00:03:18,000
an intuition

114
00:03:18,000 --> 00:03:20,400
for how it works maybe a great way to

115
00:03:20,400 --> 00:03:21,040
start off

116
00:03:21,040 --> 00:03:22,959
is to actually begin by discussing what

117
00:03:22,959 --> 00:03:24,720
a cluster even is

118
00:03:24,720 --> 00:03:27,360
well cluster as you probably know is

119
00:03:27,360 --> 00:03:28,959
essentially a lot of points within your

120
00:03:28,959 --> 00:03:29,440
data

121
00:03:29,440 --> 00:03:30,879
that are close to each other that you

122
00:03:30,879 --> 00:03:32,959
want to specify as a single sort of

123
00:03:32,959 --> 00:03:34,720
group of points they belong to a

124
00:03:34,720 --> 00:03:36,959
category because they are close together

125
00:03:36,959 --> 00:03:39,120
they're one specific cloud of your data

126
00:03:39,120 --> 00:03:40,879
also known as a cluster

127
00:03:40,879 --> 00:03:43,440
but how do you define where that cluster

128
00:03:43,440 --> 00:03:44,000
is

129
00:03:44,000 --> 00:03:45,680
well the way that you do with k-means

130
00:03:45,680 --> 00:03:47,760
clustering is by defining what's known

131
00:03:47,760 --> 00:03:49,040
as a centroid

132
00:03:49,040 --> 00:03:52,080
a centroid is the point at the center of

133
00:03:52,080 --> 00:03:53,200
that cluster

134
00:03:53,200 --> 00:03:55,519
such that all the points that have the

135
00:03:55,519 --> 00:03:56,239
closest

136
00:03:56,239 --> 00:03:58,879
distance to that centroid are part of

137
00:03:58,879 --> 00:04:00,879
that cluster if they're closer to a

138
00:04:00,879 --> 00:04:02,000
different centroid

139
00:04:02,000 --> 00:04:04,720
they're part of that centroid cluster

140
00:04:04,720 --> 00:04:06,480
and so the way that k-means works

141
00:04:06,480 --> 00:04:08,080
is that you start off by putting these

142
00:04:08,080 --> 00:04:10,239
centroids in random locations

143
00:04:10,239 --> 00:04:12,239
the way that i'm initializing it is by

144
00:04:12,239 --> 00:04:14,239
taking the average point of the entire

145
00:04:14,239 --> 00:04:16,479
data space and just creating a couple of

146
00:04:16,479 --> 00:04:18,799
different sort of variations around that

147
00:04:18,799 --> 00:04:19,759
general center

148
00:04:19,759 --> 00:04:21,759
area what that gives me is then a bunch

149
00:04:21,759 --> 00:04:23,600
of points that can move into their own

150
00:04:23,600 --> 00:04:25,840
cluster spaces

151
00:04:25,840 --> 00:04:28,240
uh now in order to achieve this goal i

152
00:04:28,240 --> 00:04:30,000
have two functions on screen right now

153
00:04:30,000 --> 00:04:31,759
the update assignments function and then

154
00:04:31,759 --> 00:04:34,080
the update centroids function

155
00:04:34,080 --> 00:04:36,080
now these two functions do two different

156
00:04:36,080 --> 00:04:37,199
things first of all

157
00:04:37,199 --> 00:04:39,440
the update assignments function will

158
00:04:39,440 --> 00:04:41,040
take a bunch of data as well as the

159
00:04:41,040 --> 00:04:42,560
locations for centroids

160
00:04:42,560 --> 00:04:44,160
and it's going to tell you which

161
00:04:44,160 --> 00:04:46,720
centroids which data points belong to

162
00:04:46,720 --> 00:04:48,400
so for example the first data point is

163
00:04:48,400 --> 00:04:50,800
closest to the second centroid and so on

164
00:04:50,800 --> 00:04:51,680
and so forth

165
00:04:51,680 --> 00:04:53,840
now using that information we can do two

166
00:04:53,840 --> 00:04:54,720
things

167
00:04:54,720 --> 00:04:56,320
first of all we can make it so that

168
00:04:56,320 --> 00:04:58,320
given data and a bunch of centroids we

169
00:04:58,320 --> 00:05:00,320
can figure out which data points belong

170
00:05:00,320 --> 00:05:01,360
to which clusters

171
00:05:01,360 --> 00:05:03,120
so we can for example color them

172
00:05:03,120 --> 00:05:05,759
accordingly now second we also then have

173
00:05:05,759 --> 00:05:07,440
the ability to run what's known as the

174
00:05:07,440 --> 00:05:07,840
next

175
00:05:07,840 --> 00:05:10,000
k-means iteration now what that's going

176
00:05:10,000 --> 00:05:12,320
to do is it's going to move our initial

177
00:05:12,320 --> 00:05:12,720
guess

178
00:05:12,720 --> 00:05:14,560
of where exactly those centroids should

179
00:05:14,560 --> 00:05:16,960
be in what we think is the correct

180
00:05:16,960 --> 00:05:17,919
direction

181
00:05:17,919 --> 00:05:19,680
the way these iterations work is quite

182
00:05:19,680 --> 00:05:21,120
simple and you can see that

183
00:05:21,120 --> 00:05:23,840
in the update centroids function inside

184
00:05:23,840 --> 00:05:25,759
of the update centroids function what

185
00:05:25,759 --> 00:05:26,400
i'm doing

186
00:05:26,400 --> 00:05:28,400
is essentially saying all right let's

187
00:05:28,400 --> 00:05:30,240
take a look at all of the different

188
00:05:30,240 --> 00:05:32,320
cluster assignments at the moment say we

189
00:05:32,320 --> 00:05:34,479
only have two centroids and we have 10

190
00:05:34,479 --> 00:05:35,759
data points

191
00:05:35,759 --> 00:05:37,759
take the data points that are part of

192
00:05:37,759 --> 00:05:38,960
the first cluster

193
00:05:38,960 --> 00:05:40,400
and the data points that are part of the

194
00:05:40,400 --> 00:05:42,320
second cluster and find

195
00:05:42,320 --> 00:05:44,960
the middle of both of those current

196
00:05:44,960 --> 00:05:46,639
guesses of clusters

197
00:05:46,639 --> 00:05:48,960
and those two middles are now the new

198
00:05:48,960 --> 00:05:50,960
locations of the centroids

199
00:05:50,960 --> 00:05:53,360
then recalculate which points are

200
00:05:53,360 --> 00:05:54,960
closest to which centroids

201
00:05:54,960 --> 00:05:57,520
and then again find the average and

202
00:05:57,520 --> 00:05:58,479
continue

203
00:05:58,479 --> 00:06:00,400
keep looping until you think you've

204
00:06:00,400 --> 00:06:01,840
reached good performance

205
00:06:01,840 --> 00:06:03,600
there are many ways of calculating this

206
00:06:03,600 --> 00:06:05,120
performance for example

207
00:06:05,120 --> 00:06:06,639
you could calculate what's known as the

208
00:06:06,639 --> 00:06:08,240
sum of squared errors

209
00:06:08,240 --> 00:06:11,039
the sum of the squared distance from

210
00:06:11,039 --> 00:06:13,280
your centroid to all of its individual

211
00:06:13,280 --> 00:06:13,919
points

212
00:06:13,919 --> 00:06:16,000
when you reach a low enough value then

213
00:06:16,000 --> 00:06:18,800
you know you fit your data well

214
00:06:18,800 --> 00:06:20,560
now in this case if we were to go

215
00:06:20,560 --> 00:06:21,919
through the data that i've prepared here

216
00:06:21,919 --> 00:06:23,520
or rather the code

217
00:06:23,520 --> 00:06:24,639
as you can see i'm starting off with

218
00:06:24,639 --> 00:06:26,240
some very classic simple imports

219
00:06:26,240 --> 00:06:28,319
importing numpy and matplotlib

220
00:06:28,319 --> 00:06:30,240
then after the imports first order of

221
00:06:30,240 --> 00:06:32,240
business is to define the functions i

222
00:06:32,240 --> 00:06:33,759
was talking about so as i mentioned

223
00:06:33,759 --> 00:06:34,000
there's

224
00:06:34,000 --> 00:06:35,600
update assignments and there's update

225
00:06:35,600 --> 00:06:37,919
centroids assignments will tell us

226
00:06:37,919 --> 00:06:40,240
which clusters or which centroids

227
00:06:40,240 --> 00:06:41,919
certain data points belong to

228
00:06:41,919 --> 00:06:43,840
and update centroids will take those

229
00:06:43,840 --> 00:06:45,600
assignments as well as the data

230
00:06:45,600 --> 00:06:47,360
and figure out where the centroids

231
00:06:47,360 --> 00:06:49,039
should actually be now

232
00:06:49,039 --> 00:06:50,639
and of course multiple iterations of

233
00:06:50,639 --> 00:06:52,160
both those functions back to back and

234
00:06:52,160 --> 00:06:54,639
you should get pretty good centroids

235
00:06:54,639 --> 00:06:56,479
now in order to actually do those

236
00:06:56,479 --> 00:06:58,240
iterations i've actually gone ahead and

237
00:06:58,240 --> 00:06:58,800
taken just

238
00:06:58,800 --> 00:07:00,639
some sample data i'll actually show you

239
00:07:00,639 --> 00:07:02,560
this data in a moment

240
00:07:02,560 --> 00:07:04,479
and using that sample data we can go

241
00:07:04,479 --> 00:07:05,919
ahead and experiment with some

242
00:07:05,919 --> 00:07:07,039
clustering

243
00:07:07,039 --> 00:07:08,880
i load that in through this data file

244
00:07:08,880 --> 00:07:10,639
over here and i transpose it

245
00:07:10,639 --> 00:07:14,479
so that we have a shape of 52

246
00:07:14,479 --> 00:07:19,039
so the shape is going to be 50 comma 2.

247
00:07:19,039 --> 00:07:21,919
effectively this means uh 50 data points

248
00:07:21,919 --> 00:07:23,840
with two dimensions each

249
00:07:23,840 --> 00:07:27,440
um and so once we have that i just go

250
00:07:27,440 --> 00:07:28,800
ahead and print out the shape

251
00:07:28,800 --> 00:07:31,199
and then i run the task i was talking

252
00:07:31,199 --> 00:07:32,560
about which is that iteration of

253
00:07:32,560 --> 00:07:34,160
consistently finding assignments and

254
00:07:34,160 --> 00:07:36,000
then updating centroids

255
00:07:36,000 --> 00:07:37,840
um we start off by guessing where the

256
00:07:37,840 --> 00:07:39,680
centroids should be so once again just

257
00:07:39,680 --> 00:07:41,520
in the very middle of the data with some

258
00:07:41,520 --> 00:07:43,919
minor movements here and there just so

259
00:07:43,919 --> 00:07:45,440
we actually get them moving in different

260
00:07:45,440 --> 00:07:46,080
directions

261
00:07:46,080 --> 00:07:47,599
otherwise they would all be moving in

262
00:07:47,599 --> 00:07:49,039
the same direction if all the centroids

263
00:07:49,039 --> 00:07:50,560
were the same

264
00:07:50,560 --> 00:07:52,639
and then i just go ahead and start

265
00:07:52,639 --> 00:07:54,160
looping um

266
00:07:54,160 --> 00:07:57,599
100 times i will do that sort of dance

267
00:07:57,599 --> 00:07:58,000
of

268
00:07:58,000 --> 00:07:59,680
finding the assignments and finding

269
00:07:59,680 --> 00:08:01,360
where the new centroids should be based

270
00:08:01,360 --> 00:08:03,360
off of those assignments

271
00:08:03,360 --> 00:08:05,440
and then once that is done i go ahead

272
00:08:05,440 --> 00:08:06,720
and plot out the data

273
00:08:06,720 --> 00:08:09,440
so i plot all the data with one color

274
00:08:09,440 --> 00:08:11,199
and then all the centroids with another

275
00:08:11,199 --> 00:08:12,000
color so that we can

276
00:08:12,000 --> 00:08:14,240
see where the centers of the clusters

277
00:08:14,240 --> 00:08:15,759
actually are

278
00:08:15,759 --> 00:08:17,680
and then from there i just go ahead and

279
00:08:17,680 --> 00:08:19,199
show the plot and

280
00:08:19,199 --> 00:08:20,879
in theory we should have implemented

281
00:08:20,879 --> 00:08:22,960
k-means clustering from scratch

282
00:08:22,960 --> 00:08:24,080
let's go ahead and take a look at if

283
00:08:24,080 --> 00:08:27,039
this actually worked out

284
00:08:27,039 --> 00:08:29,039
so if i go ahead and quit or rather i

285
00:08:29,039 --> 00:08:30,879
guess i'd save because i commented some

286
00:08:30,879 --> 00:08:31,919
code there

287
00:08:31,919 --> 00:08:35,519
if i go ahead and run k-means dot py

288
00:08:35,519 --> 00:08:38,640
we should be able to see there we go

289
00:08:38,640 --> 00:08:41,360
we see our data over here that's all the

290
00:08:41,360 --> 00:08:42,399
blue points

291
00:08:42,399 --> 00:08:44,800
as well as the three clusters that we

292
00:08:44,800 --> 00:08:46,080
were able to identify

293
00:08:46,080 --> 00:08:49,279
in orange now these three clusters are

294
00:08:49,279 --> 00:08:49,920
of course

295
00:08:49,920 --> 00:08:52,800
within sort of i guess you could say

296
00:08:52,800 --> 00:08:54,160
they're close to the center

297
00:08:54,160 --> 00:08:55,920
of their respective regions like

298
00:08:55,920 --> 00:08:57,440
visually as a human if you were to sort

299
00:08:57,440 --> 00:08:58,880
of look here

300
00:08:58,880 --> 00:09:01,600
you can identify that there are overall

301
00:09:01,600 --> 00:09:03,040
three sort of clusters of data here

302
00:09:03,040 --> 00:09:04,000
there's the one

303
00:09:04,000 --> 00:09:05,519
over here to the left there's the one

304
00:09:05,519 --> 00:09:06,720
over here to the right and of course

305
00:09:06,720 --> 00:09:07,279
there's one

306
00:09:07,279 --> 00:09:10,160
down here below as well the one towards

307
00:09:10,160 --> 00:09:12,080
the top can be a little bit harder to

308
00:09:12,080 --> 00:09:12,560
sort of

309
00:09:12,560 --> 00:09:14,000
exactly distinguish where the clusters

310
00:09:14,000 --> 00:09:15,600
begin and end

311
00:09:15,600 --> 00:09:17,040
however it is still pretty easily

312
00:09:17,040 --> 00:09:19,279
possible and that's what k-means is

313
00:09:19,279 --> 00:09:21,200
actually doing for us

314
00:09:21,200 --> 00:09:22,800
as a matter of fact i can actually

315
00:09:22,800 --> 00:09:25,360
change the number of clusters

316
00:09:25,360 --> 00:09:27,680
that we want to run against so for

317
00:09:27,680 --> 00:09:28,399
example

318
00:09:28,399 --> 00:09:30,560
i couldn't instead say we want to we

319
00:09:30,560 --> 00:09:32,720
want to get four clusters right so this

320
00:09:32,720 --> 00:09:35,760
axis over here defines how many clusters

321
00:09:35,760 --> 00:09:37,440
or how many centroids we want to

322
00:09:37,440 --> 00:09:38,160
generate

323
00:09:38,160 --> 00:09:39,920
and this is just how many dimensions per

324
00:09:39,920 --> 00:09:42,080
centroid which is two because our

325
00:09:42,080 --> 00:09:44,880
our data is two dimensional so i can

326
00:09:44,880 --> 00:09:47,200
change that three to a four

327
00:09:47,200 --> 00:09:49,279
and i should just be able to run my code

328
00:09:49,279 --> 00:09:51,120
and there we go as you can see now we

329
00:09:51,120 --> 00:09:51,760
have

330
00:09:51,760 --> 00:09:55,920
four centroids and in this specific case

331
00:09:55,920 --> 00:09:57,760
we didn't really need more than three

332
00:09:57,760 --> 00:09:58,560
right there's only

333
00:09:58,560 --> 00:10:00,399
really three clusters here but if you

334
00:10:00,399 --> 00:10:02,720
were to force k means to use a fourth

335
00:10:02,720 --> 00:10:03,760
centroid

336
00:10:03,760 --> 00:10:05,519
in this specific case thanks to the

337
00:10:05,519 --> 00:10:07,519
random initialization we got

338
00:10:07,519 --> 00:10:09,440
this is where the next centroid goes

339
00:10:09,440 --> 00:10:11,200
however it's absolutely possible that it

340
00:10:11,200 --> 00:10:12,959
could go pretty much anywhere else

341
00:10:12,959 --> 00:10:14,720
it could go in between the two clusters

342
00:10:14,720 --> 00:10:16,480
over here but it just so happened that

343
00:10:16,480 --> 00:10:17,279
k-means

344
00:10:17,279 --> 00:10:19,279
based off of the random initialization

345
00:10:19,279 --> 00:10:20,480
said that you know what

346
00:10:20,480 --> 00:10:22,640
um over here it would make most sense

347
00:10:22,640 --> 00:10:23,839
because of

348
00:10:23,839 --> 00:10:27,120
um say this one outlier over here um

349
00:10:27,120 --> 00:10:30,640
that approximately seven 1.4 right so

350
00:10:30,640 --> 00:10:33,120
um or yeah so negative seven one point

351
00:10:33,120 --> 00:10:34,079
four um

352
00:10:34,079 --> 00:10:37,279
to to be exact um and so that's how k

353
00:10:37,279 --> 00:10:39,200
means clustering works i mean i must say

354
00:10:39,200 --> 00:10:40,480
when i actually implemented this from

355
00:10:40,480 --> 00:10:41,040
scratch

356
00:10:41,040 --> 00:10:42,959
i was kind of surprised as to how simple

357
00:10:42,959 --> 00:10:44,800
the algorithm really is and how elegant

358
00:10:44,800 --> 00:10:46,720
it can be um you take a look at

359
00:10:46,720 --> 00:10:48,240
algorithms like this and you wonder you

360
00:10:48,240 --> 00:10:48,640
know

361
00:10:48,640 --> 00:10:50,079
they're probably pretty complex because

362
00:10:50,079 --> 00:10:52,079
a lot of modern machine learning is

363
00:10:52,079 --> 00:10:53,760
you know a lot of different things sort

364
00:10:53,760 --> 00:10:55,279
of put into a single package

365
00:10:55,279 --> 00:10:57,120
but k-means is one of those really basic

366
00:10:57,120 --> 00:10:58,880
algorithms that is incredibly useful

367
00:10:58,880 --> 00:11:01,040
right if it's if it ain't broke don't

368
00:11:01,040 --> 00:11:03,120
fix it so that's exactly what uh what

369
00:11:03,120 --> 00:11:05,440
k-mean sort of personifies here

370
00:11:05,440 --> 00:11:06,959
and hopefully this was helpful for to

371
00:11:06,959 --> 00:11:08,959
you uh sort of figuring out how the

372
00:11:08,959 --> 00:11:10,959
world of unsupervised learning works

373
00:11:10,959 --> 00:11:13,040
and how you can implement your own

374
00:11:13,040 --> 00:11:14,720
machine learning algorithms of course

375
00:11:14,720 --> 00:11:16,480
this code is down in the description

376
00:11:16,480 --> 00:11:18,000
below so feel free to go ahead and check

377
00:11:18,000 --> 00:11:18,880
it out

378
00:11:18,880 --> 00:11:21,360
and run it for yourself uh and of course

379
00:11:21,360 --> 00:11:22,800
if you did enjoy this video please do

380
00:11:22,800 --> 00:11:24,079
make sure to subscribe to the channel

381
00:11:24,079 --> 00:11:25,519
once again it really does help out a lot

382
00:11:25,519 --> 00:11:27,200
turn on notifications so you're notified

383
00:11:27,200 --> 00:11:28,880
whenever i release new content

384
00:11:28,880 --> 00:11:30,240
and of course feel free to leave any

385
00:11:30,240 --> 00:11:31,680
suggestions feedback and of course

386
00:11:31,680 --> 00:11:33,200
questions down in the comments section

387
00:11:33,200 --> 00:11:34,320
below or feel free

388
00:11:34,320 --> 00:11:36,959
to email me or tweet to me at tajimani

389
00:11:36,959 --> 00:11:37,680
of course though

390
00:11:37,680 --> 00:11:39,120
thank you very much for joining today

391
00:11:39,120 --> 00:11:43,040
and goodbye everybody
